<?xml version="1.0" encoding="UTF-8"?>
<!-- Copyright 2010-2011 NexJ Systems Inc. This software is licensed under the terms of the Eclipse Public License 1.0 -->

<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <xsd:simpleType name="identifier">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value=":?[\p{L}_][\p{L}\p{N}_]*(:[\p{L}_][\p{L}\p{N}_]*)*"/>
         <!--
            Value must begin with a letter or an underscore.
            Case and length are not restricted.
            Letters, numbers and underscores are allowed.
            Colon is used as a scope separator.
            Spaces and other punctuation characters are not allowed. 
         -->
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="messagePartIdentifier">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value=":?[\p{L}_][\p{L}\p{N}\.\-_]*(:[\p{L}_][\p{L}\p{N}\.\-_]*)*"/>
         <!--
            Value must begin with a letter or an underscore.
            Case and length are not restricted.
            Letters, numbers, underscores, dashes, colons and periods are allowed.
            Spaces and other punctuation characters are not allowed. 
         -->
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="identifierList">
      <xsd:restriction base="xsd:token">
         <xsd:pattern value="(:?[\p{L}_][\p{L}\p{N}_]*(:[\p{L}_][\p{L}\p{N}_]*)*\s+)*(:?[\p{L}_][\p{L}\p{N}_]*(:[\p{L}_][\p{L}\p{N}_]*)*)?"/>
         <!--
            Each element in the list must begin with a letter or underscore.
            Elements are space delimited.
         -->
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="identifierListStar">
      <xsd:restriction base="xsd:token">
         <xsd:pattern value="(\*|(:?[\p{L}_][\p{L}\p{N}_]*(:[\p{L}_][\p{L}\p{N}_]*)*\s+)*(:?[\p{L}_][\p{L}\p{N}_]*(:[\p{L}_][\p{L}\p{N}_]*)*)?(\s+\*)?)"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="aspectList">
      <xsd:restriction base="xsd:token">
         <xsd:pattern value="(!?:?[\p{L}_][\p{L}\p{N}_]*(:[\p{L}_][\p{L}\p{N}_]*)*\s+)*(!?:?[\p{L}_][\p{L}\p{N}_]*(:[\p{L}_][\p{L}\p{N}_]*)*)?"/>
         <!--
            Each element in the list must begin with a letter or underscore. Elements are space delimited.
            To exclude a token, prefix it with the character "!".
         -->
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="actionName">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[\p{L}_][\p{L}\p{N}_]*(:[\p{L}_][\p{L}\p{N}_]*)?"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="fragmentName">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[\p{L}\p{N}\-_:]+"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="tableName">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[A-Za-z][_A-Za-z\d]*(\.[A-Za-z][_A-Za-z\d]*)?"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="tableType">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="managed"/>
         <!--
         Managed tables are managed by the upgrade framework.
         They are included when generating upgrade, create, drop... DDL scripts.
         Prefixing is also applied to this type of table.
         -->
         <xsd:enumeration value="external"/>
         <!--
         External tables are excluded when generating DDL scripts and Prefixing.
         -->
         <xsd:enumeration value="query"/>
         <!--
         The table is a cached result, a.k.a. materialized query table, a.k.a. materialized view, a.k.a. indexed view.
         -->
         <xsd:enumeration value="view"/>
         <!--
         The table is a view.
         -->
         <xsd:enumeration value="aspect"/>
         <!--
         Aspect tables are table elements (columns, indexes, ...) that may be appended to other "managed" tables.
         They do not represent real tables in the generated schema.  An Aspect Table is appended to all tables (or other Aspects) that
         either specify it by name in their "aspects" property or match the Aspect Table's "pointcut" property.  If a table matches
         the aspect's "poincut" property but excludes the aspect by name in its "aspects" property, the aspect will not be applied to
         that table.
         -->
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="indexName">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[A-Za-z][_A-Za-z\d]*(\.[A-Za-z][_A-Za-z\d]*){0,2}"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="dbObjName">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[A-Za-z][_A-Za-z\d]*"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="componentName">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value=":?[\p{L}_][\p{L}\p{N}_]*((:|\.)[\p{L}_][\p{L}\p{N}_]*)*"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="qualJavaName">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[\p{L}_][\p{L}\p{N}_]*(\.[\p{L}_][\p{L}\p{N}_]*)*"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="alias">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[\p{L}_][\p{L}\p{N}\-_]*"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="primitiveType">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="string"/>
         <xsd:enumeration value="binary"/>
         <xsd:enumeration value="integer"/>
         <xsd:enumeration value="long"/>
         <xsd:enumeration value="decimal"/>
         <xsd:enumeration value="float"/>
         <xsd:enumeration value="double"/>
         <xsd:enumeration value="timestamp"/>
         <xsd:enumeration value="boolean"/>
         <xsd:enumeration value="any"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="columnType">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="string"/>
         <xsd:enumeration value="binary"/>
         <xsd:enumeration value="integer"/>
         <xsd:enumeration value="long"/>
         <xsd:enumeration value="decimal"/>
         <xsd:enumeration value="float"/>
         <xsd:enumeration value="double"/>
         <xsd:enumeration value="timestamp"/>
         <xsd:enumeration value="boolean"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="flowMacroArgType">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="string"/>
         <xsd:enumeration value="binary"/>
         <xsd:enumeration value="integer"/>
         <xsd:enumeration value="long"/>
         <xsd:enumeration value="decimal"/>
         <xsd:enumeration value="float"/>
         <xsd:enumeration value="double"/>
         <xsd:enumeration value="timestamp"/>
         <xsd:enumeration value="boolean"/>
         <xsd:enumeration value="any"/>
         <xsd:enumeration value="list"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="columnAllocation">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="fixed"/>
         <xsd:enumeration value="varying"/>
         <xsd:enumeration value="locator"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="visibility">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="public"/>
         <xsd:enumeration value="protected"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="transaction">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="supported"/>
         <!--
            Join a transaction, if available, otherwise run transactionless.
            @detail
            If the caller is running within a transaction and invokes the event, the event executes
            within the caller's transaction.  If the caller is not associated with a transaction,
            a new transaction is not started for the event i.e. run transactionless.

            Because the transactional behavior of the event may vary, you should use 'supported' with
            caution. (similar to JTA Supports)
         -->
         <xsd:enumeration value="required"/>
         <!--
            Join a transaction, if available, otherwise start a new transaction.  Do not auto-commit on return.
            @detail
            If the caller is running within  a transaction and invokes the event, the event executes within
            the caller's transaction.  If the caller is not associated with a transaction, a new transaction
            will start for the event.  Do not auto-commit before returning to the caller. (similar to JTA Required)
         -->
         <xsd:enumeration value="new"/>
         <!--
            Always suspend the current transaction, if any, and start a new one.  Auto-commit on return.
            @detail
            If the caller is running within a transaction and invokes the event, the caller takes the
            following steps:

               1. Suspend the caller's transaction
               2. Start a new transaction
               3. Call the event
               4. Commit and resume the callers transaction when the event returns

            If the caller is not associated with a transaction, a new transaction is started before
            calling the event.  Auto-commit on return.

            You should use 'new' when you want to ensure that the event always runs within a new transaction. (similar to JTA RequiresNew)
         -->
         <xsd:enumeration value="none"/>
         <!--
            Always suspend the current transaction, if any.  Restore on return.
            @detail
            If the caller is running within a transaction and invokes the event, suspend the callers
            transaction and call the event without a transaction.  After the event has completed,
            resume the caller's transaction.

            If the caller is not associated with a transaction, run the event transactionless.

            Use 'none' for events that don't need transactions.  Because transactions involve
            overhead, this may impove performance.  (similar to JTA NotSupported)
         -->
         <xsd:enumeration value="mandatory"/>
         <!--
            Fail if there is no transaction.
            @detail
            If the caller is running within a transaction and invokes the event, the event executes
            within the caller's transaction.  If the caller is not associated with a transaction, the
            event will throw an exception.  Use 'mandatory' if the event must use the transaction of
            the caller. (similar to JTA Mandatory)
         -->
         <xsd:enumeration value="unsupported"/>
         <!--
            Fail if there is a transaction.
            @detail
            If the caller is running within a transaction and invokes the event, the event throws an
            exception.  If the caller is not associated with a transaction, a transaction is not
            started for the event. (similar to JTA Never)
         -->
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="cascade">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="none"/>
         <xsd:enumeration value="delete"/>
         <xsd:enumeration value="clear"/>
         <xsd:enumeration value="cancel"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="directive">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="if"/>
         <xsd:enumeration value="ifnot"/>
         <xsd:enumeration value="ifdef"/>
         <xsd:enumeration value="ifndef"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="serverType">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="Generic"/>
         <!--
         NexJ Application Server
         @detail
         NJAS (also known as TEEE).  This server type is used for local execution, debugging and unit testing.
         -->
         <xsd:enumeration value="JBoss"/>
         <!--
         JBoss Application Server
         @detail
         www.jboss.com
         -->
         <xsd:enumeration value="WebSphere"/>
         <!--
         IBM WebSphere Application Server
         @detail
         www.ibm.com/websphere
         -->
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="pushType">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="streaming"/>
         <!--
         The default push mode. Uses "streaming" type Comet for notifications.  
         -->
         <xsd:enumeration value="long"/>
         <!--
         Uses "long polling" type Comet for notifications
         -->
         <xsd:enumeration value="none"/>
         <!--
         Do not use the push server for notifications - periodic polling is used.
         -->
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="authProtocol">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="basic"/>
         <!--
         Basic username / password authentication
         -->
         <xsd:enumeration value="spnego"/>
         <!--
         SPNEGO authentication - http://en.wikipedia.org/wiki/SPNEGO
         -->
         <xsd:enumeration value="certificate"/>
         <!--
         Certificate based authentication
         -->
         <xsd:enumeration value="perimeter"/>
         <!--
         Token based SSO authentication
         -->
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="resource">
      <xsd:restriction base="xsd:string"/>
   </xsd:simpleType>

   <xsd:simpleType name="password">
      <xsd:restriction base="xsd:string"/>
   </xsd:simpleType>

   <xsd:simpleType name="onErrorType">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="fail"/>
         <xsd:enumeration value="collect"/>
         <xsd:enumeration value="commit"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="selectionType">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="single"/>
         <xsd:enumeration value="multiple"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="uimode">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="modal"/>
         <xsd:enumeration value="modeless"/>
         <xsd:enumeration value="sdi"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="positiveUnsignedShort">
      <xsd:restriction base="xsd:unsignedShort">
         <xsd:minInclusive value="1"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="nonNegativeInt">
      <xsd:restriction base="xsd:int">
         <xsd:minInclusive value="0"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="positiveInt">
      <xsd:restriction base="xsd:int">
         <xsd:minInclusive value="1"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="nonNegativeLong">
      <xsd:restriction base="xsd:long">
         <xsd:minInclusive value="0"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="nonNegativeDouble">
      <xsd:restriction base="xsd:double">
         <xsd:minInclusive value="0"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:simpleType name="hex">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[0-9A-fa-f]*"/>
      </xsd:restriction>
   </xsd:simpleType>

   <xsd:complexType name="ResourceRef">
      <xsd:attribute name="resource" type="resource" use="required"/>
      <xsd:attribute name="directive" type="directive"/>
      <xsd:attribute name="condition" type="xsd:string"/>
      <xsd:attribute name="enabled" type="xsd:boolean"/>
      <xsd:attribute name="merged" type="xsd:boolean" default="false"/>
   </xsd:complexType>

   <xsd:complexType name="Metadata">
      <xsd:sequence>
         <xsd:element name="Mixins" minOccurs="0" maxOccurs="1">
            <xsd:complexType> 
               <xsd:sequence>
                  <xsd:element name="Mixin" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:attribute name="namespace" type="xsd:anyURI" use="required"/>
                        <xsd:attribute name="version" type="xsd:string" use="required"/>
                        <xsd:attribute name="checksum" type="hex" use="required"/>
                        <xsd:attribute name="override" type="xsd:boolean" default="false"/>
                        <xsd:attribute name="upgradeNamespace" type="xsd:anyURI"/>
                        <xsd:attribute name="upgradeVersion" type="xsd:string"/>
                        <xsd:attribute name="upgradeChecksum" type="hex"/>
                        <xsd:attribute name="base" type="xsd:boolean"/>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Imports" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Import" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:attribute name="resource" type="resource" use="required"/>
                        <xsd:attribute name="as" type="identifier"/>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Resources" minOccurs="0" maxOccurs="1">
            <!--
            Explicit references may be excluded from metadata loading.
            -->
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="ResourceRef" type="ResourceRef" minOccurs="0" maxOccurs="unbounded"/>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="skip"/>
      </xsd:sequence>
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <xsd:attribute name="revision" type="xsd:string" use="required"/>
      <xsd:attribute name="namespace" type="xsd:anyURI" use="required"/>
      <!--
         A globally unique URI that identifies the model. Used for metadata, persistence storage and RPC request matching.
         @detail
         Because of uniqueness requirement, using a registered domain name is recommended.
         @example
         A CRM model created for Example Inc. might use the value:  http://www.example.com/ns/crm
      -->
      <xsd:attribute name="version" type="xsd:string" use="required"/>
      <xsd:attribute name="baseNamespace" type="xsd:anyURI"/>
      <xsd:attribute name="baseVersion" type="xsd:string"/>
      <xsd:attribute name="baseChecksum" type="hex"/>
      <xsd:attribute name="upgradeNamespace" type="xsd:anyURI"/>
      <xsd:attribute name="upgradeVersion" type="xsd:string"/>
      <xsd:attribute name="upgradeChecksum" type="hex"/>
      <xsd:attribute name="compatibleNamespace" type="xsd:anyURI"/>
      <xsd:attribute name="compatibleVersion" type="xsd:string"/>
      <xsd:attribute name="compatibleChecksum" type="hex"/>
      <xsd:attribute name="coreVersion">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:pattern value="[\p{N}]+(\.[\p{N}]+)*\+?"/>
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <xsd:attribute name="module" type="identifier"/>
      <xsd:attribute name="override" type="xsd:boolean"/>
      <xsd:attribute name="description" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="DataSourceType">
      <xsd:sequence>
         <xsd:element name="Adapters" minOccurs="1" maxOccurs="1">
         <!--
            Collection of Adapters for a DataSourceType.
         -->
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Adapter" minOccurs="1" maxOccurs="unbounded">
                  <!--
                     Persistence Adapter of a particular DataSourceType.  e.g. DB2, Oracle, MSSQL for RelationalDatabase
                  -->
                     <xsd:complexType>
                        <xsd:attribute name="name" type="xsd:string" use="required"/>
                        <!--
                           Uniquely identifies the Persistence Adapter.
                        -->
                        <xsd:attribute name="class" type="qualJavaName" use="required"/>
                        <!--
                           Persistence adapter Java class, implementing the PersistenceAdapter interface.
                           @category Settings
                        -->
                        <xsd:attribute name="version" type="xsd:string"/>
                        <!--
                           Persistence adapter compatibility version, passed to its implementation component.
                           @category Settings
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="element" type="identifier" use="required"/>
      <!--
         Data source metadata root XML element name.
         @category Settings
      -->
      <xsd:attribute name="loader" type="qualJavaName" use="required"/>
      <!--
         Data source and connection loader class, implementing the XMLPersistenceMetadataLoader interface.
         @category Settings
      -->
      <xsd:attribute name="exporter" type="qualJavaName"/>
      <!--
         Data source exporter, implementing the XMLPersistenceMetadataExporter interface.
         @category Settings
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Data source type description.
      -->
   </xsd:complexType>

   <xsd:complexType name="DataSourceTypes">
      <xsd:sequence>
         <xsd:element name="DataSourceType" minOccurs="0" maxOccurs="unbounded">
         <!--
            @context Extends DatasourceType
         -->
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="DataSourceType">
                     <xsd:attribute name="name" type="xsd:string" use="required"/>
                     <!--
                        Uniquely identifies the Data Source Type.
                     -->
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>

   <xsd:complexType name="DataSource">
      <xsd:sequence>
         <xsd:element name="Properties" type="ComponentProperties" minOccurs="0" maxOccurs="1"/>
         <!--
            @context Component
         -->
      </xsd:sequence>
      <xsd:attribute name="read" type="xsd:boolean" default="true"/>
      <!--
         True if instance retrieval is supported.
         @category Behavior
      -->
      <xsd:attribute name="create" type="xsd:boolean" default="true"/>
      <!--
         True if instance creation is supported.
         @category Behavior
      -->
      <xsd:attribute name="update" type="xsd:boolean" default="true"/>
      <!--
         True if instance updating is supported.
         @category Behavior
      -->
      <xsd:attribute name="delete" type="xsd:boolean" default="true"/>
      <!--
         True if instance deletion is supported.
         @category Behavior
      -->
      <xsd:attribute name="execute" type="xsd:boolean" default="true"/>
      <!--
         True if instance execution is supported.
         @category Behavior
      -->
      <xsd:attribute name="join" type="xsd:boolean" default="true"/>
      <!--
         Not supported.
         @detail
         Currently, joins are not supported across DataSources.  When this feature is implemented, this value will be true if schema objects from this data source can be joined to objects from another data source.
         @category Behavior
      -->
      <xsd:attribute name="readLimit" type="nonNegativeInt" default="4096"/>
      <!--
         The maximum number of instances that can be returned by read() (0 for unlimited).
         @category Behavior
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Data source description.
      -->
   </xsd:complexType>

   <xsd:complexType name="RelationalColumn">
      <xsd:attribute name="name" type="dbObjName" use="required"/>
      <!--
         Uniquely identifies the column.
      -->
      <xsd:attribute name="type" type="columnType"/>
      <!--
         Column data type.
         @category Type
      -->
      <xsd:attribute name="precision" type="positiveInt"/>
      <!--
         Column precision (decimal, integer) or length (string, binary). For integer columns, it is the number of bytes (1, 2 or 4).
         @category Type
      -->
      <xsd:attribute name="scale" type="xsd:unsignedByte"/>
      <!--
         Decimal number scale.
         @category Type
      -->
      <xsd:attribute name="allocation" type="columnAllocation"/>
      <!--
         Column allocation mode. If a given mode is not supported on a given RDMBS, it is degraded automatically.
         @category Type
      -->
      <xsd:attribute name="nullable" type="xsd:boolean" default="true"/>
      <!--
         True if the column is nullable. It can be automatically set to false based on required mapped attributes and column participation
         in the primary key.
         @category Type
      -->
      <xsd:attribute name="caseInsensitive" type="xsd:boolean" default="true"/>
      <!--
         Applicable to string columns only. True if the column is case insensitive for searching. (default = true)
         @detail
         It can be automatically set to false if the column participates
         in primary or foreign keys, is a class code or is longer than 2000 characters.
         @category Type
      -->
      <xsd:attribute name="converter" type="xsd:string"/>
      <!--
         Component for custom column data type conversion, implementing the Converter interface.
         @category Expert
      -->
      <xsd:attribute name="literal" type="xsd:boolean" default="false"/>
      <!--
         True to disable the bind parameter on this column and use a literal bind instead.
         @category Expert
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Column description.
      -->
   </xsd:complexType>

   <xsd:complexType name="RelationalIndex">
      <xsd:sequence>
         <xsd:element name="IndexColumn" minOccurs="0" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:attribute name="name" type="dbObjName" use="required"/>
               <!--
                  Uniquely identifies the IndexColumn.
               -->
               <xsd:attribute name="ascending" type="xsd:boolean" default="true"/>
               <!--
                  True to store the column values in ascending order.
               -->
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="name" type="indexName" use="required"/>
      <!--
         Index name, unique within the schema. It is usually prefixed by the table name: [<owner>.]<table>.<index>
      -->
      <xsd:attribute name="type" default="btree">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:enumeration value="btree"/>
               <!--
               btree works well for non-primitive attribute mapping. They are used as foreign keys. In these cases one should
               not create physical foreign keys (as opposed to just indexes) in the database.
               -->
               <xsd:enumeration value="cluster"/>
               <!--
               An index on which most searches/sorts on table occur should be "clustered", unless a lot of insertions are expected on the table.
               -->
               <xsd:enumeration value="text"/>
               <!--
               Text indexes are used to speed up full text search, and not usually used by DBMS for regular data lookup.
               -->
               <xsd:enumeration value="query"/>
               <!--
               Virtual index which counts as a sort key. It should be used as a hint to the framework
               only in place of a btree or a cluster index that is not used by the database.
               -->
               <xsd:enumeration value="virtual"/>
               <!--
               If a physical index is not needed (e.g. if another index starts with the same columns,
               or it is not anticipated that it will be used by the optimizer), set its type to "virtual".
               A typical case when a physical index is not needed is when it contains the same columns with
               the same sort direction that start another index. E.g. if four physical indexes are needed
               on the same table, A(a,b), B(a,b,c,d), C(a, c) and D(b,c), then A is redundant and should
               be virtual, as the database can use B instead, but C and D define a different sort order
               than B, so they should not be marked as virtual.
               -->
               <xsd:enumeration value="aspect"/>
               <!--
               Aspect indexes are index column sets that can be prepended to other non-aspect indexes.
               They do not represent real indexes in the generated schema.  An Aspect index is prepended to all
               non-aspect indexes that specify it by name in their "aspects" property.
               -->
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <!--
         Index type.

         @detail
         Virtual indexes are used only for column grouping and do not correspond to physical indexes in the database.
         They often are a subset of a physical index's columns.

         Query indexes are virtual indexes that can function as sort keys.

         Btree creates a physical B-tree index in the database.

         Cluster creates a physical clustered index in the database. A table can have at most one clustered index.

         Text indexes are used to speed up full text search, and not usually used by DBMS for regular data lookup.

         Aspect indexes define index columns that may be prepended to other non-aspect indexes.
      -->
      <xsd:attribute name="aspects" type="aspectList"/>
      <!--
         List of names of aspect indexes to include in or exclude from (if prefixed with !) this index.  If an
         aspect index will be included in this index, the aspect index's columns are pre-pended to this index's
         columns.
         @category Aspect
      -->
      <xsd:attribute name="unique" type="xsd:boolean" default="false"/>
      <!--
         True if the index is unique.
      -->
      <xsd:attribute name="relatedTable" type="tableName"/>
      <!--
         Table referenced by this index serving as a foreign key.
      -->
      <xsd:attribute name="fill" type="xsd:unsignedByte"/>
      <!--
         Index page fill factor percent, 1-100 (0 for the database default, empty for the schema default).
         @category Allocation
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Index description.
      -->
   </xsd:complexType>

   <xsd:complexType name="RelationalObject">
      <!--
         A metadata managed, but not referenced, Database Object other than a table/view/index. This object is created/dropped by the metadata but not explicitly used by the metadata.
      -->
      <xsd:sequence>
         <xsd:element name="Prerequisites" type="Prerequisites" minOccurs="0" maxOccurs="1"/>
         <xsd:element name="Create" type="SQLSwitch"/>
         <!--
            SQL required to create the Database object.
         -->
         <xsd:element name="Drop" type="SQLSwitch"/>
         <!--
            SQL required to drop the Database object.
         -->
      </xsd:sequence>
      <xsd:attribute name="name" type="tableName" use="required"/>
      <!--
         Database object name, may include the schema name: [<schema>.]<object>
      -->
   </xsd:complexType>

   <xsd:complexType name="RelationalTable">
      <xsd:sequence>
         <xsd:element name="Prerequisites" type="Prerequisites" minOccurs="0" maxOccurs="1"/>
         <xsd:element name="Columns" minOccurs="0">
          <!--
              @context Database Table
          -->
            <xsd:annotation>
               <xsd:appinfo>
                  <Collection ordered="false"/>
               </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Column" type="RelationalColumn" minOccurs="1" maxOccurs="unbounded"/>
                  <!--
                     @context Database Table
                  -->
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Indexes" minOccurs="0">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Index" type="RelationalIndex" minOccurs="1" maxOccurs="unbounded"/>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="View" minOccurs="0">
            <!--
               @context Database View
            -->
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="SQLSwitch">
                     <xsd:attribute name="autoupdated" type="xsd:boolean" default="true"/>
                     <!--
                        Should the view contents be updated automatically. Applies only to "query" table type, always "true" otherwise.
                     -->
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="name" type="tableName" use="required"/>
      <!--
         Table name, may include the owner: [<owner>.]<table>
      -->
      <xsd:attribute name="alias" type="xsd:string"/>
      <!--
         Physical name of the table. Overrides the name and the prefix. It should be properly quoted, if necessary. Allowed only in non-portable schemas for non-managed tables.
         @category Expert
      -->
      <xsd:attribute name="type" type="tableType" default="managed"/>
      <!--
         Table type. External tables are excluded from DDL scripts. Aspect table definition is appended to all matching pointcuts.
      -->
      <xsd:attribute name="pointcuts" type="xsd:string"/>
      <!--
         List of table name patterns (with * and ?) where matches will include or exclude (if prefixed with !) this aspect.
         @category Aspect
      -->
      <xsd:attribute name="aspects" type="aspectList"/>
      <!--
         List of names of aspect tables to include in or exclude from (if prefixed with !) this table.  If an
         aspect table will be included in this table, the aspect tables's columns and indexes are appended to
         this table's items.
         @category Aspect
      -->
      <xsd:attribute name="hints" type="identifierList"/>
      <!--
         List of hints to add to the table.
      -->
      <xsd:attribute name="primaryKey" type="indexName"/>
      <!--
         Table primary key unique index. For query tables use a virtual index.
      -->
      <xsd:attribute name="tablespace" type="dbObjName"/>
      <!--
         Tablespace or file group name. Use "default" for the database default.
         @category Allocation
      -->
      <xsd:attribute name="indexspace" type="dbObjName"/>
      <!--
         Index tablespace or file group name. Use "default" for the database default.
         @category Allocation
      -->
      <xsd:attribute name="longspace" type="dbObjName"/>
      <!--
         Long column tablespace or file group name. Use "default" for the database default.
         @category Allocation
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Table description.
      -->
   </xsd:complexType>

   <xsd:complexType name="RelationalDatabase">
      <xsd:complexContent>
         <xsd:extension base="DataSource">
            <xsd:sequence>
               <xsd:element name="Tables" minOccurs="0" maxOccurs="1">
                  <xsd:annotation>
                     <xsd:appinfo>
                        <Collection ordered="false"/>
                     </xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType>
                     <xsd:sequence>
                        <xsd:element name="Table" type="RelationalTable" minOccurs="0" maxOccurs="unbounded"/>
                     </xsd:sequence>
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="Objects" minOccurs="0" maxOccurs="1">
                  <xsd:annotation>
                     <xsd:appinfo>
                        <Collection ordered="false"/>
                     </xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType>
                     <xsd:sequence>
                        <xsd:element name="Object" type="RelationalObject" minOccurs="0" maxOccurs="unbounded"/>
                     </xsd:sequence>
                  </xsd:complexType>
               </xsd:element>
            </xsd:sequence>
            <xsd:attribute name="alias" type="alias"/>
            <!--
               Data source alias for JNDI lookup.
            -->
            <xsd:attribute name="prefix">
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:pattern value="[A-Za-z][_A-Za-z\d]*(\.([A-Za-z][_A-Za-z\d]*)?)?"/>
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
            <!--
               Prefix automatically added to all managed tables without owners and aliases.
            -->
            <xsd:attribute name="portable" type="xsd:boolean" default="true"/>
            <!--
               True if schema object portability naming restrictions are enforced.
            -->
            <xsd:attribute name="indexfill" type="xsd:unsignedByte"/>
            <!--
               Default index page fill factor percent, 1-100 (0 or empty for the database default).
               @category Allocation
            -->
            <xsd:attribute name="tablespace" type="dbObjName"/>
            <!--
               Default tablespace or file group name. Use "default" for the database default.
               @category Allocation
            -->
            <xsd:attribute name="indexspace" type="dbObjName"/>
            <!--
               Default index tablespace or file group name. Use "default" for the database default.
               @category Allocation
            -->
            <xsd:attribute name="longspace" type="dbObjName"/>
            <!--
               Default long column tablespace or file group name. Use "default" for the database default.
               @category Allocation
            -->
            <xsd:attribute name="role" type="dbObjName"/>
            <!--
               Role that is granted access to the schema objects.
            -->
            <xsd:attribute name="versionTable" type="tableName"/>
            <!--
               Table name for schema version checking with columns
               @detail
               (namespace nvarchar(128) primary key, version nvarchar(128), step int, upgradable bit, test bit, loaded bit).
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="Prerequisites">
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
         <xsd:element name="Object">
            <xsd:complexType>
              <xsd:attribute name="name" type="tableName" use="required"/>
              <!--
                 This object can only be created after the specified Database Objects have been created and dropped prior to the specified Database Objects.
              -->
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Table">
            <xsd:complexType>
              <xsd:attribute name="name" type="tableName" use="required"/>
              <!--
                 This object can only be created after the specified tables have been created and dropped prior to the specified tables.
              -->
            </xsd:complexType>
         </xsd:element>
      </xsd:choice>
   </xsd:complexType>

   <xsd:complexType name="Script">
      <xsd:simpleContent>
         <xsd:extension base="xsd:string"/>
      </xsd:simpleContent>
   </xsd:complexType>

   <xsd:complexType name="SQLSwitch">
      <xsd:sequence>
         <xsd:element name="SQL" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
               <xsd:appinfo>
                  <Collection key="adapter"/>
               </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Script">
                     <xsd:attribute name="adapter" type="xsd:string" default="*"/>
                     <!--
                        Adapter names, for which the SQL is valid: a1 a2 ... aN. Patterns with * and ? are allowed.
                     -->
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <!--
            SQL statement. May contain macro variables: ${table:<name>}, ${object:<name>}, ${index:<name>}, ${ifci:<table.column>:<sql>}, ${owner}, ${owner.}, ${role}, ${concat(<arg1>,<arg2>,...)}, ${extract(<year|quarter|month|week|day|hour|minute|second|frac_second|microsecond>,<timestamp>)}, ${guid()}, ${now()}, ${sysPublicId()}, ${sysUserId()}, ${sysUserAlias()}, ${timestampadd(<year|quarter|month|week|day|hour|minute|second|frac_second|microsecond>,<delta>,<timestamp>)}, ${binary:<hex>}, ${keyword:<name>}, ${quote:<text>}.
         -->
      </xsd:sequence>
   </xsd:complexType>

   <xsd:group name="SQLScript">
      <xsd:choice>
         <xsd:element name="SQL" type="Script"/>
         <!--
            SQL statement. May contain macro variables: ${table:<name>}, ${object:<name>}, ${index:<name>}, ${ifci:<table.column>:<sql>}, ${owner}, ${owner.}, ${role}, ${concat(<arg1>,<arg2>,...)}, ${extract(<year|quarter|month|week|day|hour|minute|second|frac_second|microsecond>,<timestamp>)}, ${guid()}, ${now()}, ${sysPublicId()}, ${sysUserId()}, ${sysUserAlias()}, ${timestampadd(<year|quarter|month|week|day|hour|minute|second|frac_second|microsecond>,<delta>,<timestamp>)}, ${binary:<hex>}, ${keyword:<name>}, ${quote:<text>}.
            @context Upgrade
         -->
         <xsd:element name="Switch" type="SQLSwitch"/>
         <!--
            @context Extends SQL Upgrade
         -->
      </xsd:choice>
   </xsd:group>

   <xsd:complexType name="RelationalDatabaseUpgrade">
      <xsd:complexContent>
         <xsd:extension base="DataSourceUpgrade">
            <xsd:choice minOccurs="0" maxOccurs="unbounded">
               <xsd:element name="CreateTable" type="RelationalTable"/>
               <xsd:element name="AlterTable">
                  <xsd:complexType>
                     <xsd:attribute name="name" type="tableName" use="required"/>
                     <!--
                        Table name, as specified in the data source: [<owner>.]<table>
                     -->
                     <xsd:attribute name="alias" type="xsd:string"/>
                     <!--
                        Physical name of the table. Overrides the name and the prefix. It should be properly quoted, if necessary. Allowed only in non-portable schemas for non-managed tables.
                        @category Expert
                     -->
                     <xsd:attribute name="type" type="tableType"/>
                     <!--
                        Table type. External tables are excluded from DDL scripts. Aspect table definition is appended to all matching pointcuts.
                     -->
                     <xsd:attribute name="hints" type="aspectList"/>
                     <!--
                        List of hints to add or remove from the table. To remove a hint prefix it with a '!'.
                     -->
                     <xsd:attribute name="primaryKey" type="indexName"/>
                     <!--
                        Table primary key unique index. For query tables use a virtual index.
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Operation description.
                     -->
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="RenameTable">
                  <xsd:complexType>
                     <xsd:attribute name="name" type="tableName" use="required"/>
                     <!--
                        Old table name, as specified in the data source: [<owner>.]<table>
                     -->
                     <xsd:attribute name="to" type="tableName" use="required"/>
                     <!--
                        New table name, as specified in the data source: [<owner>.]<table>
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Operation description.
                     -->
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="DropTable">
                  <xsd:complexType>
                     <xsd:attribute name="name" type="tableName" use="required"/>
                     <!--
                        Table name, as specified in the data source: [<owner>.]<table>
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Operation description.
                     -->
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="ApplyTableAspect">
                  <xsd:annotation>
                     <xsd:appinfo>
                        <Collection key="name pointcuts"/>
                     </xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType>
                     <xsd:group ref="SQLScript" minOccurs="0" maxOccurs="unbounded"/>
                     <xsd:attribute name="name" type="tableName" use="required"/>
                     <!--
                        Table aspect name.
                     -->
                     <xsd:attribute name="pointcuts" type="xsd:string"/>
                     <!--
                        List of table name patterns (with * and ?) where matches are used to apply the aspect (exclusion patterns are prefixed with !).
                     -->
                     <xsd:attribute name="override" type="xsd:boolean" default="false"/>
                     <!--
                        True to remove conflicting aspect overrides from the pointcuts.
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Operation description.
                     -->
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="RemoveTableAspect">
                  <xsd:complexType>
                     <xsd:attribute name="name" type="tableName" use="required"/>
                     <!--
                        Table aspect name.
                     -->
                     <xsd:attribute name="pointcuts" type="xsd:string"/>
                     <!--
                        List of table name patterns (with * and ?) where matches are used to apply the aspect (exclusion patterns are prefixed with !).
                     -->
                     <xsd:attribute name="override" type="xsd:boolean" default="false"/>
                     <!--
                        True to remove conflicting aspect overrides from the pointcuts.
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Operation description.
                     -->
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="CreateColumn">
                  <xsd:annotation>
                     <xsd:appinfo>
                        <Collection key="name table"/>
                     </xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType>
                     <xsd:complexContent>
                        <xsd:extension base="RelationalColumn">
                           <xsd:group ref="SQLScript" minOccurs="0" maxOccurs="unbounded"/>
                           <xsd:attribute name="table" type="tableName" use="required"/>
                           <!--
                              Table name, as specified in the data source: [<owner>.]<table>
                           -->
                        </xsd:extension>
                     </xsd:complexContent>
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="AlterColumn">
                  <xsd:annotation>
                     <xsd:appinfo>
                        <Collection key="name table"/>
                     </xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType>
                     <xsd:attribute name="table" type="tableName" use="required"/>
                     <!--
                        Table name, as specified in the data source: [<owner>.]<table>
                     -->
                     <xsd:attribute name="name" type="dbObjName" use="required"/>
                     <!--
                        Column name.
                     -->
                     <xsd:attribute name="type" type="columnType"/>
                     <!--
                        Column data type.
                        @category Type
                     -->
                     <xsd:attribute name="precision" type="positiveInt"/>
                     <!--
                        Column precision (decimal, integer) or length (string, binary). For integer columns, it is the number of bytes (1, 2 or 4).
                        @category Type
                     -->
                     <xsd:attribute name="scale" type="xsd:unsignedByte"/>
                     <!--
                        Decimal number scale.
                        @category Type
                     -->
                     <xsd:attribute name="allocation" type="columnAllocation"/>
                     <!--
                        Column allocation mode. If a given mode is not supported on a given RDMBS, it is degraded automatically.
                        @category Type
                     -->
                     <xsd:attribute name="nullable" type="xsd:boolean"/>
                     <!--
                        True if the column is nullable.
                        @category Type
                     -->
                     <xsd:attribute name="caseInsensitive" type="xsd:boolean"/>
                     <!--
                        True if the column is case insensitive.
                        @category Type
                     -->
                     <xsd:attribute name="converter" type="xsd:string"/>
                     <!--
                        Component for custom column data type conversion, implementing the Converter interface.
                        @category Expert
                     -->
                     <xsd:attribute name="literal" type="xsd:boolean"/>
                     <!--
                        True to disable the bind parameter on this column and use a literal bind instead.
                        @category Expert
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Operation description.
                     -->
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="RenameColumn">
                  <xsd:annotation>
                     <xsd:appinfo>
                        <Collection key="name table"/>
                     </xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType>
                     <xsd:attribute name="table" type="tableName" use="required"/>
                     <!--
                        Table name, as specified in the data source: [<owner>.]<table>
                     -->
                     <xsd:attribute name="name" type="dbObjName" use="required"/>
                     <!--
                        Old column name.
                     -->
                     <xsd:attribute name="to" type="dbObjName" use="required"/>
                     <!--
                        New column name.
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Operation description.
                     -->
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="DropColumn">
                  <xsd:annotation>
                     <xsd:appinfo>
                        <Collection key="name table"/>
                     </xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType>
                     <xsd:attribute name="table" type="tableName" use="required"/>
                     <!--
                        Table name, as specified in the data source: [<owner>.]<table>
                     -->
                     <xsd:attribute name="name" type="dbObjName" use="required"/>
                     <!--
                        Column name.
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Operation description.
                     -->
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="CreateIndex">
                  <xsd:complexType>
                     <xsd:complexContent>
                        <xsd:extension base="RelationalIndex">
                           <xsd:attribute name="table" type="tableName" use="required"/>
                           <!--
                              Table name, as specified in the data source: [<owner>.]<table>
                           -->
                        </xsd:extension>
                     </xsd:complexContent>
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="RenameIndex">
                  <xsd:complexType>
                     <xsd:attribute name="name" type="indexName" use="required"/>
                     <!--
                        Old index name, as specified in the data source: [<owner>.]<table>.<index>
                     -->
                     <xsd:attribute name="to" type="indexName" use="required"/>
                     <!--
                        New index name, as specified in the data source: [<owner>.]<table>.<index>
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Operation description.
                     -->
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="DropIndex">
                  <xsd:complexType>
                     <xsd:attribute name="name" type="indexName" use="required"/>
                     <!--
                        Index name, as specified in the data source: [<owner>.]<table>.<index>
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Operation description.
                     -->
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="ApplyIndexAspect">
                  <xsd:complexType>
                     <xsd:attribute name="name" type="tableName" use="required"/>
                     <!--
                        Index aspect name.
                     -->
                     <xsd:attribute name="pointcuts" type="xsd:string"/>
                     <!--
                        List of name patterns (with * and ?) of indexes, to which to apply the aspect (exclusion patterns are prefixed with !).
                     -->
                     <xsd:attribute name="override" type="xsd:boolean" default="false"/>
                     <!--
                        True to remove conflicting aspect overrides from the pointcuts.
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Operation description.
                     -->
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="RemoveIndexAspect">
                  <xsd:complexType>
                     <xsd:attribute name="name" type="tableName" use="required"/>
                     <!--
                        Index aspect name.
                     -->
                     <xsd:attribute name="pointcuts" type="xsd:string"/>
                     <!--
                        List of name patterns (with * and ?) of indexes, from which to remove the aspect (exclusion patterns are prefixed with !).
                     -->
                     <xsd:attribute name="override" type="xsd:boolean" default="false"/>
                     <!--
                        True to remove conflicting aspect overrides from the pointcuts.
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Operation description.
                     -->
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="CreateObject">
                  <xsd:complexType>
                     <xsd:complexContent>
                        <xsd:extension base="SQLSwitch">
                           <xsd:attribute name="name" type="tableName" use="required"/>
                           <!--
                              Database Object name to create, as specified in the data source: [<schema>.]<Object>
                           -->
                           <xsd:attribute name="description" type="xsd:string"/>
                           <!--
                              Operation description.
                           -->
                        </xsd:extension>
                     </xsd:complexContent>
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="DropObject">
                  <xsd:complexType>
                     <xsd:complexContent>
                        <xsd:extension base="SQLSwitch">
                           <xsd:attribute name="name" type="tableName" use="required"/>
                           <!--
                              Database Object name to drop, as specified in the data source: [<schema>.]<Object>
                           -->
                           <xsd:attribute name="description" type="xsd:string"/>
                           <!--
                              Operation description.
                           -->
                        </xsd:extension>
                     </xsd:complexContent>
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="Exec">
                  <xsd:annotation>
                     <xsd:appinfo>
                        <Collection key="description"/>
                     </xsd:appinfo>
                  </xsd:annotation>
                  <xsd:complexType>
                     <xsd:group ref="SQLScript" minOccurs="0" maxOccurs="unbounded"/>
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Operation description.
                     -->
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="SupportAdapter">
                  <xsd:complexType>
                     <xsd:attribute name="name" type="xsd:string" use="required"/>
                     <!--
                        Persistence Adapter name for which support begins at the current step.
                     -->
                  </xsd:complexType>
               </xsd:element>
            </xsd:choice>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="FileStorage">
      <xsd:complexContent>
         <xsd:extension base="DataSource"/>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="ServiceDataSource">
      <xsd:complexContent>
         <xsd:extension base="DataSource"/>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="GenericDataSource">
      <xsd:complexContent>
         <xsd:extension base="DataSource">
            <xsd:sequence>
               <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
            </xsd:sequence>
            <xsd:attribute name="type" type="xsd:string" use="required"/>
            <!--
               Data source type.
            -->
            <xsd:anyAttribute processContents="lax"/>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="DataSourceConnection">
      <xsd:annotation>
         <xsd:appinfo>
            <Collection key="dataSource"/>
         </xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="dataSource" type="xsd:string" use="required"/>
      <!--
         Connection data source.
      -->
      <xsd:attribute name="adapter" type="xsd:string"/>
      <!--
         Data source adapter.
      -->
      <xsd:attribute name="readLimit" type="nonNegativeInt"/>
      <!--
         The maximum number of instances that can be returned by read() (0 for unlimited). Overrides the data source setting.
         @category Behavior
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Data source connection description.
      -->
   </xsd:complexType>

   <xsd:complexType name="DataSourceUpgrade">
      <xsd:annotation>
         <xsd:appinfo>
            <Collection key="version dataSource"/>
         </xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="version" type="xsd:string"/>
      <!--
         Unique string identifying the repository version. Empty for virtual upgrade steps providing context for subsequent steps.
      -->
      <xsd:attribute name="dataSource" type="xsd:string" use="required"/>
      <!--
         Data source name.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Data source upgrade description.
      -->
   </xsd:complexType>

   <xsd:complexType name="UnitTest">
      <xsd:sequence>
         <xsd:element name="Loops" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Loop" minOccurs="1" maxOccurs="unbounded">
                     <!--
                        Loops iterate over the unit test with each combination of all "looped" variables. 
                        @detail
                        During each iteration one of the variables will advance to the next value in its
                        list of values.  In this way, the unit test will be evaluated against the combination
                        of all sets of variables.
                     -->
                     <xsd:complexType>
                        <xsd:attribute name="variable" type="identifier" use="required"/>
                        <!--
                           The variable to set on each iteration. Must have different name from unit test variables and other loop variables.
                        -->
                        <xsd:attribute name="type" default="list">
                           <xsd:simpleType>
                              <xsd:restriction base="xsd:string">
                                 <xsd:enumeration value="list"/>
                                 <!--
                                    A list of symbols.
                                    @example
                                    DAV SOAP
                                 -->
                                 <xsd:enumeration value="expression"/>
                                 <!--
                                    Any expression that evaluates to a collection. Outer loop variables are in scope to inner loop expressions.
                                    @example
                                    '(DAV SOAP)
                                 -->
                              </xsd:restriction>
                           </xsd:simpleType>
                        </xsd:attribute>
                        <!--
                           The type of the value over which to iterate.  "list" or "expression"
                           @detail
                           The variable's value will either iterate over a list of symbols or an expression that returns a list.
                        -->
                        <xsd:attribute name="value" type="xsd:string" use="required"/>
                        <!--
                           The constant list or expression to iterate over.
                           @detail
                           If the type is "expression", the outer loop variables are in scope for the value's expression.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Initializer" type="Script" minOccurs="0" maxOccurs="1"/>
         <!--
            Code that will execute before each test case.
            @detail
            This script will execute before each test case regardless of the unit test's mode - "dirty" or "sequential".
            It is typically used to set up data on which the test cases will depend.
         -->
         <xsd:element name="TestCase" minOccurs="0" maxOccurs="unbounded">
         <!--
            Script used to test a unit of functionality in a unit test
            @detail
            Test cases are scripts evaluated during unit tests.  These scripts have access to special
            assert statements to compare actual to expected results.
            Some special script functions used in test cases include:
            <pre>
            * assert-equal
            * assert-eq
            * assert=
            * assert-null
            * assert-raises
            * assert-invariant
            * assert-true
            * assert-error-code
            * reset-context
            </pre>
         -->
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Script">
                     <xsd:attribute name="name" type="xsd:string"/>
                     <!--
                        The name of the Test Case.  It must be unique.
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        The description of what functional area of the Unit Test this Test Case tests.
                     -->
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Finalizer" type="Script" minOccurs="0" maxOccurs="1"/>
         <!--
            Code that will execute after each test case.
            @detail
            This script will execute after each test case regardless of the UnitTest's mode - "dirty" or "sequential".
            It is typically used to tear down unmanaged resources.
         -->
      </xsd:sequence>
      <xsd:attribute name="dump" type="xsd:string"/>
      <!--
         The database dump file used to import a new seeded database.
         @detail
         The database dump will be restored before each test case in "sequential" mode or only once at the
         beginning of the unit test in "dirty" mode.
      -->
      <xsd:attribute name="variables" type="identifierList"/>
      <!--
         Unit Test variables: var1 var2 ... varN; global to initializer, finalizer, and test cases.
         @detail
         Initialized to null at the start of the test and at the beginning of each loop.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         A description of what functional area the unit test covers.
      -->
      <xsd:attribute name="mode" default="sequential">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:enumeration value="sequential"/>
               <!--
                 The database dump will be restored before each test case is run.
               -->
               <xsd:enumeration value="dirty"/>
               <!--
                 The database dump will be restored once at the beginning of the unit test.
               -->
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <!--
         The run mode. "dirty" means no database resetting is required between each test case run.
      -->
   </xsd:complexType>

   <xsd:complexType name="Upgrade">
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
         <xsd:element name="Label">
         <!--
            @context Upgrade
         -->
            <xsd:annotation>
               <xsd:appinfo>
                  <Collection key="version"/>
               </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:attribute name="version" type="xsd:string" use="required"/>
               <!--
                  Unique string identifying the repository version.
               -->
               <xsd:attribute name="description" type="xsd:string"/>
               <!--
                  Label upgrade description.
               -->
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Load">
            <xsd:annotation>
               <xsd:appinfo>
                  <Collection key="version"/>
               </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:attribute name="version" type="xsd:string" use="required"/>
               <!--
                  Unique string identifying the repository version.
               -->
               <xsd:attribute name="description" type="xsd:string" default="Reseed database"/>
               <!--
                  Load upgrade description.
               -->
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Script">
         <!--
            @context Upgrade
         -->
            <xsd:annotation>
               <xsd:appinfo>
                  <Collection key="version"/>
               </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Script">
                     <xsd:attribute name="version" type="xsd:string" use="required"/>
                     <!--
                        Unique string identifying the repository version.
                     -->
                     <xsd:attribute name="description" type="xsd:string"/>
                     <!--
                        Script upgrade description.
                     -->
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="RelationalDatabaseUpgrade" type="RelationalDatabaseUpgrade"/>
         <xsd:any processContents="lax"/>
      </xsd:choice>
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         The upgrade description.
      -->
   </xsd:complexType>

   <xsd:complexType name="SOADefinition">
      <xsd:sequence>
         <xsd:element name="Service" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Interfaces" minOccurs="0" maxOccurs="1">
                     <xsd:annotation>
                        <xsd:appinfo>
                           <Collection ordered="false"/>
                        </xsd:appinfo>
                     </xsd:annotation>
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:element name="Interface" minOccurs="1" maxOccurs="unbounded">
                              <xsd:annotation>
                                 <xsd:appinfo>
                                    <Collection key="ref"/>
                                 </xsd:appinfo>
                              </xsd:annotation>
                              <xsd:complexType>
                                 <xsd:attribute name="ref" type="xsd:string" use="required"/>
                                 <!--
                                    The interface name, unqualified or fully-qualified. If unqualified, then
                                    only this SOA definition is searched for a matching interface. Use a
                                    fully-qualified name to reference an interface from another SOA
                                    definition. 
                                 -->
                                 <xsd:attribute name="default" type="xsd:boolean" default="false"/>
                                 <!--
                                    True if this interface is the default interface for the service. There
                                    may be only one default interface for a service.
                                 -->
                              </xsd:complexType>
                           </xsd:element>
                        </xsd:sequence>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Interfaces" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
               <xsd:appinfo>
                  <Collection ordered="false"/>
               </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Interface" minOccurs="0" maxOccurs="unbounded">
                     <xsd:annotation>
                        <xsd:appinfo>
                           <Collection ordered="false"/>
                        </xsd:appinfo>
                     </xsd:annotation>
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:element name="Method" minOccurs="0" maxOccurs="unbounded">
                              <xsd:annotation>
                                 <xsd:appinfo>
                                    <Collection key="name [*]"/>
                                 </xsd:appinfo>
                              </xsd:annotation>
                              <xsd:complexType>
                                 <xsd:sequence>
                                    <xsd:element name="Arguments" minOccurs="0" maxOccurs="1">
                                       <xsd:complexType>
                                          <xsd:sequence>
                                             <xsd:element name="Argument" minOccurs="0" maxOccurs="unbounded">
                                                <xsd:complexType>
                                                   <xsd:attribute name="name" type="identifier" use="required"/>
                                                   <!--
                                                      The argument name.
                                                   -->
                                                   <xsd:attribute name="type" type="xsd:string" use="required"/>
                                                   <!--
                                                      The type name, unqualified or fully-qualified. Use unqualified to reference
                                                      a type in this SOA definition; fully-qualified to reference a type in
                                                      another SOA definition. May also be a framework primitive type name.
                                                   -->
                                                   <xsd:attribute name="collection" type="xsd:boolean" default="false"/>
                                                   <!--
                                                      True if this parameter is a collection of the specified type.
                                                   -->
                                                   <xsd:attribute name="description" type="xsd:string"/>
                                                   <!--
                                                      The argument description.
                                                   -->
                                                </xsd:complexType>
                                             </xsd:element>
                                          </xsd:sequence>
                                       </xsd:complexType>
                                    </xsd:element>
                                    <xsd:element name="Result" minOccurs="0" maxOccurs="1">
                                       <xsd:complexType>
                                          <xsd:attribute name="type" type="xsd:string" use="required"/>
                                          <!--
                                             The type name, unqualified or fully-qualified. Use unqualified to reference
                                             a type in this SOA definition; fully-qualified to reference a type in
                                             another SOA definition. May also be a framework primitive type name.
                                          -->
                                          <xsd:attribute name="collection" type="xsd:boolean" default="false"/>
                                          <!--
                                             True if the return value is a collection of the specified type.
                                          -->
                                          <xsd:attribute name="description" type="xsd:string"/>
                                          <!--
                                             The result description.
                                          -->
                                       </xsd:complexType>
                                    </xsd:element>
                                    <xsd:element name="Faults" minOccurs="0" maxOccurs="1">
                                       <xsd:complexType>
                                          <xsd:sequence>
                                             <xsd:element name="Fault" minOccurs="0" maxOccurs="unbounded">
                                                <xsd:annotation>
                                                   <xsd:appinfo>
                                                      <Collection key="type"/>
                                                   </xsd:appinfo>
                                                </xsd:annotation>
                                                <xsd:complexType>
                                                   <xsd:attribute name="type" type="xsd:string" use="required"/>
                                                   <!--
                                                      The type name, unqualified or fully-qualified. Use unqualified to reference
                                                      a type in this SOA definition; fully-qualified to reference a type in
                                                      another SOA definition.
                                                   -->
                                                </xsd:complexType>
                                             </xsd:element>
                                          </xsd:sequence>
                                       </xsd:complexType>
                                    </xsd:element>
                                 </xsd:sequence>
                                 <xsd:attribute name="name" type="identifier" use="required"/>
                                 <!--
                                    The method name.
                                 -->
                                 <xsd:attribute name="description" type="xsd:string"/>
                                 <!--
                                    The method description.
                                 -->
                                 <xsd:attribute name="state" type="xsd:string"/>
                                 <!--
                                    The type of the method state parameter. May be unqualified or fully-qualified. Leave
                                    unspecified if the method is stateless.
                                 -->
                              </xsd:complexType>
                           </xsd:element>
                        </xsd:sequence>
                        <xsd:attribute name="name" type="identifier" use="required"/>
                        <!--
                           The interface name, unqualified.
                        -->
                        <xsd:attribute name="description" type="xsd:string"/>
                        <!--
                           The interface description.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Enumerations" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Enumeration" minOccurs="0" maxOccurs="unbounded">
                     <xsd:annotation>
                        <xsd:appinfo>
                           <Collection ordered="false"/>
                        </xsd:appinfo>
                     </xsd:annotation>
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:element name="Item" minOccurs="1" maxOccurs="unbounded">
                              <xsd:complexType>
                                 <xsd:attribute name="name" type="identifier" use="required"/>
                                 <!--
                                    The name of this item in the enumeration.
                                 -->
                                 <xsd:attribute name="description" type="xsd:string"/>
                                 <!--
                                    The description for this item.
                                 -->
                              </xsd:complexType>
                           </xsd:element>
                        </xsd:sequence>
                        <xsd:attribute name="name" type="identifier" use="required"/>
                        <!--
                           The enumeration name, unqualified.
                        -->
                        <xsd:attribute name="description" type="xsd:string"/>
                        <!--
                           The enumeration description.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Types" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Type" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:element name="Attributes" minOccurs="0" maxOccurs="1">
                              <xsd:annotation>
                                 <xsd:appinfo>
                                    <Collection ordered="false"/>
                                 </xsd:appinfo>
                              </xsd:annotation>
                              <xsd:complexType>
                                 <xsd:sequence>
                                    <xsd:element name="Attribute" minOccurs="0" maxOccurs="unbounded">
                                       <xsd:complexType>
                                          <xsd:attribute name="name" type="identifier" use="required"/>
                                          <!--
                                             The attribute name.
                                          -->
                                          <xsd:attribute name="type" type="xsd:string" use="required"/>
                                          <!--
                                             The type name, unqualified or fully-qualified. Use unqualified to reference
                                             a type in this SOA definition; fully-qualified to reference a type in
                                             another SOA definition. May also be a framework primitive type name.
                                          -->
                                          <xsd:attribute name="required" type="xsd:boolean" default="false"/>
                                          <!--
                                             True if the attribute must be non-null.
                                          -->
                                          <xsd:attribute name="collection" type="xsd:boolean" default="false"/>
                                          <!--
                                             True if the attribute is a collection of the specified type.
                                          -->
                                          <xsd:attribute name="description" type="xsd:string"/>
                                          <!--
                                             The attribute description.
                                          -->
                                       </xsd:complexType>
                                    </xsd:element>
                                 </xsd:sequence>
                              </xsd:complexType>
                           </xsd:element>
                        </xsd:sequence>
                        <xsd:attribute name="name" type="identifier" use="required"/>
                        <!--
                           The type name, unqualified.
                        -->
                        <xsd:attribute name="bases" type="xsd:string"/>
                        <!--
                           The base type or types (space-separated list).
                        -->
                        <xsd:attribute name="description" type="xsd:string"/>
                        <!--
                           The type description.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Faults" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Fault" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:element name="Attributes" minOccurs="0" maxOccurs="1">
                              <xsd:annotation>
                                 <xsd:appinfo>
                                    <Collection ordered="false"/>
                                 </xsd:appinfo>
                              </xsd:annotation>
                              <xsd:complexType>
                                 <xsd:sequence>
                                    <xsd:element name="Attribute" minOccurs="0" maxOccurs="unbounded">
                                       <xsd:complexType>
                                          <xsd:attribute name="name" type="identifier" use="required"/>
                                          <!--
                                             The attribute name.
                                          -->
                                          <xsd:attribute name="type" type="xsd:string" use="required"/>
                                          <!--
                                             The type name, unqualified or fully-qualified. Use unqualified to reference
                                             a type in this SOA definition; fully-qualified to reference a type in
                                             another SOA definition. May also be a framework primitive type name.
                                          -->
                                          <xsd:attribute name="required" type="xsd:boolean" default="false"/>
                                          <!--
                                             True if the attribute must be non-null.
                                          -->
                                          <xsd:attribute name="collection" type="xsd:boolean" default="false"/>
                                          <!--
                                             True if the attribute is a collection of the specified type.
                                          -->
                                          <xsd:attribute name="description" type="xsd:string"/>
                                          <!--
                                             The attribute description.
                                          -->
                                       </xsd:complexType>
                                    </xsd:element>
                                 </xsd:sequence>
                              </xsd:complexType>
                           </xsd:element>
                        </xsd:sequence>
                        <xsd:attribute name="name" type="identifier" use="required"/>
                        <!--
                           The fault name, unqualified.
                        -->
                        <xsd:attribute name="bases" type="xsd:string"/>
                        <!--
                           The base fault or faults (space-separated list).
                        -->
                        <xsd:attribute name="description" type="xsd:string"/>
                        <!--
                           The fault description.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Diagrams" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Diagram" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="skip"/>
                        </xsd:sequence>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Bindings" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Binding" minOccurs="1" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:attribute name="protocol" type="identifier"/>
                        <!--
                           The binding protocol name.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Channels" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Channel" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:complexContent>
                           <xsd:extension base="Channel">
                              <xsd:attribute name="name" type="identifier" use="required"/>
                              <!--
                                 The channel name.
                              -->
                           </xsd:extension>
                        </xsd:complexContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="IntegrationInterfaces" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Interface" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:complexContent>
                           <xsd:extension base="Interface">
                              <xsd:attribute name="name" type="identifier" use="required"/>
                              <!--
                                 The interface name.
                              -->
                           </xsd:extension>
                        </xsd:complexContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Libraries" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Library" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:complexContent>
                           <xsd:extension base="Script">
                              <xsd:attribute name="name" type="identifier" use="required"/>
                              <!--
                                 The library name.
                              -->
                           </xsd:extension>
                        </xsd:complexContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Messages" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Message" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:complexContent>
                           <xsd:extension base="Message">
                              <xsd:attribute name="name" type="identifier" use="required"/>
                              <!--
                                 The message name.
                              -->
                           </xsd:extension>
                        </xsd:complexContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="IntegrationServices" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Service" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:complexContent>
                           <xsd:extension base="Service">
                              <xsd:attribute name="name" type="identifier" use="required"/>
                              <!--
                                 The service name.
                              -->
                           </xsd:extension>
                        </xsd:complexContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Transformations" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Transformation" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:complexContent>
                           <xsd:extension base="Transformation">
                              <xsd:attribute name="name" type="identifier" use="required"/>
                              <!--
                                 The transformation name.
                              -->
                           </xsd:extension>
                        </xsd:complexContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="name" type="identifier" use="required"/>
      <!--
         The definition name.
      -->
      <xsd:attribute name="version" type="xsd:string" default="1.0"/>
      <!--
         The definition version.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         A description of the definition.
      --> 
   </xsd:complexType>

   <xsd:complexType name="SOAImplementation">
      <xsd:annotation>
         <xsd:appinfo>
            <Collection ordered="false" key="service"/>
         </xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element name="Interface" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
               <xsd:appinfo>
                  <Collection ordered="false"/>
               </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Method" minOccurs="0" maxOccurs="unbounded">
                     <xsd:annotation>
                        <xsd:appinfo>
                           <Collection key="name args"/>
                        </xsd:appinfo>
                     </xsd:annotation>
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:element name="Script" type="Script" minOccurs="0" maxOccurs="1"/>
                           <!--
                              The script to execute when this method is called.
                           -->
                        </xsd:sequence>
                        <xsd:attribute name="name" type="identifier" use="required"/>
                        <!--
                           The method name.
                        -->
                        <xsd:attribute name="args" type="xsd:string"/>
                        <!--
                           The method arguments. Used to disambiguate the method from other methods with the same
                           name.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
               <xsd:attribute name="name" type="xsd:string" use="required"/>
               <!--
                  The name of the interface being implemented. Fully-qualified only if this interface is from
                  a different SOA definition file than the service.
               -->
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="service" type="xsd:string" use="required"/>
      <!--
         The fully-qualified name of the service that is implemented.
      -->
   </xsd:complexType>

   <xsd:complexType name="ChannelType">
      <xsd:attribute name="element" type="identifier" use="required"/>
      <!--
         Channel metadata XML element name.
      -->
      <xsd:attribute name="loader" type="qualJavaName" use="required"/>
      <!--
         Metadata loader Java class, implementing the XMLIntegrationMetadataLoader interface.
      -->
      <xsd:attribute name="exporter" type="qualJavaName"/>
      <!--
         Metadata exporter Java class, implementing the XMLIntegrationMetadataExporter interface.
      -->
      <xsd:attribute name="sender" type="qualJavaName" use="required"/>
      <!--
         Sender component Java class, implementing the Sender interface, and possibly, the Responder interface.
      -->
      <xsd:attribute name="receiver" type="qualJavaName"/>
      <!--
         Receiver component Java class.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Channel type description.
      -->
   </xsd:complexType>

   <xsd:complexType name="ChannelTypes">
      <xsd:sequence>
         <xsd:element name="ChannelType" minOccurs="0" maxOccurs="unbounded">
          <!--
              @context Extends ChannelType
          -->
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="ChannelType">
                     <xsd:attribute name="name" type="xsd:string" use="required"/>
                     <!--
                        Channel type name.
                     -->
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>

   <xsd:complexType name="Channel">
      <xsd:sequence>
         <xsd:element name="SenderProperties" type="ComponentProperties" minOccurs="0" maxOccurs="1"/>
         <xsd:element name="ReceiverProperties" type="ComponentProperties" minOccurs="0" maxOccurs="1"/>
         <xsd:element name="ServiceBindings" minOccurs="0" maxOccurs="1">
         <!--
         Services bound to the incomming traffic on the channel.
         @detail
         Each Channel may have a set of one or more service bindings.  When a channel receives a message from an external system, the bound services will be invoked with this message.
         <pre>
         When a channel is bound multiple services  ->
         When multiple services are bound to a channel and a message is forwarded to more than one of those services,
         the initial "this" variable in those services refers to the same object. This should be taken into account if the original
         message object can be updated in any of the services  you might want to modify a copy of the message instead.
         </pre>
         -->
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="ServiceBinding" minOccurs="0" maxOccurs="unbounded">
               <!--
                   A Service bound to the incomming traffic on the channel.
                   @detail
                   Each Channel may have a a set of one or more service bindings.  Channels that are configure to receive
                   are called by external systems.  When we bind a service to a channel, the service will be invoked
                   on any messages received on the channel.
                -->
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:element name="Arguments" minOccurs="0" maxOccurs="1">
                           <!--
                              Collection of Arguments for a Channel's ServiceBinding
                              @context Service Binding
                           -->
                              <xsd:complexType>
                                 <xsd:sequence>
                                    <xsd:element name="Argument" minOccurs="0" maxOccurs="unbounded">
                                    <!--
                                       Argument for a Channel's ServiceBinding.
                                       @context Service Binding
                                    -->
                                       <xsd:complexType>
                                          <xsd:attribute name="name" type="xsd:string" use="required"/>
                                          <!--
                                             Service argument name.
                                          -->
                                          <xsd:attribute name="channel" type="xsd:string"/>
                                          <!--
                                             Service argument channel. Either a channel or a value can be passed.
                                          -->
                                          <xsd:attribute name="value" type="xsd:string"/>
                                          <!--
                                             Service argument value expression. Either a channel or a value can be passed.
                                          -->
                                       </xsd:complexType>
                                    </xsd:element>
                                 </xsd:sequence>
                              </xsd:complexType>
                           </xsd:element>
                        </xsd:sequence>
                        <xsd:attribute name="service" type="xsd:string" use="required"/>
                        <!--
                           Service name.
                        -->
                        <xsd:attribute name="output" type="xsd:string"/>
                        <!--
                           Service output channel sets the default output channel for the bound Service.
                        -->
                        <xsd:attribute name="description" type="xsd:string"/>
                        <!--
                           Service binding description.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="send" type="xsd:boolean" default="true"/>
      <!--
         True if the channel can send messages.
         @category Sender
      -->
      <xsd:attribute name="receive" type="xsd:boolean" default="true"/>
      <!--
         True if the channel can receive messages.
         @category Receiver
      -->
      <xsd:attribute name="stealth" type="xsd:boolean" default="false"/>
      <!--
         True to supress the debug logging, unless nexj.system.core.meta.integration.Channel.<name> category dump logging is enabled.
         @category Receiver
      -->
      <xsd:attribute name="category" type="xsd:string"/>
      <!--
         The category of the channel.
      -->
      <xsd:attribute name="combine" default="none">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:enumeration value="none"/>
               <!--
                  Multiple services declaring the same message in their associated Interface Request messages are not supported. (Default)
               -->
               <xsd:enumeration value="first"/>
               <!--
                  Only the first one among the bound services with a matching message in their Interface Request messages is invoked.
               -->
               <xsd:enumeration value="all"/>
               <!--
                  All the services with a matching message in their Interface Request messages are invoked.
                  @detail
                  When multiple services are bound to a channel and a message is forwarded to more than one of those services,
                  the initial "this" variable in those services refers to the same object. This should be taken into account if the original
                  message object can be updated in any of the services  you might want to modify a copy of the message instead.
               -->
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <!--
         Resolution algorithm for multiple bound services processing the same message. (Default none - meaning multiple services with the same message is not supported)
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Channel description.
      -->
   </xsd:complexType>

   <xsd:complexType name="MessageQueue">
      <xsd:complexContent>
         <xsd:extension base="Channel">
            <xsd:attribute name="alias" type="alias"/>
            <!--
               Alias used for JNDI lookup.
               @detail
               Set manually based on the existing or desired server configuration of JNDI queue/topic names.
               During "Configure Server", any unknown queues or topics are created.
            -->
            <xsd:attribute name="broadcast" type="xsd:boolean" default="false"/>
            <!--
               True if the MessageQueue broadcasts messages to a topic (i.e. it is a publish/subscribe topic, not a P2P queue).
               @detail
               True if the channel is bound to a publish/subscribe topic and false if the channel is bound to a P2P queue.
               During "Configure Server", any JNDI resourse that is unknown, based on the alias name, will be created
               as a queue if broadcast is false or as a topic if it is true.
               @category Broadcast
            -->
            <xsd:attribute name="acknowledgement" default="transacted">
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:enumeration value="transacted"/>
                     <!--
                        This is the default.  If the associated transaction is committed, the consumed messages are acknowledged,
                        and any produced messages are sent. If it is rolled back, the produced messages are destroyed,
                        and consumed messages are recovered.
                     -->
                     <xsd:enumeration value="auto"/>
                     <!--
                  Follows the policy of delivering the message once-and-only once but this incurs an overhead on the server.
                  For each message, the session automatically acknowledges that a client has received a message as soon
                  as the message is received.  If a JMS provider or the message consumer crashes while it is processing a
                  message, the message is subject to either re-delivery or loss.
                -->
                     <xsd:enumeration value="lazy"/>
                     <!--
                        The session acknowledges message lazily, which provides faster message processing,
                        with the penalty that some duplicate messages may be delivered multiple times if JMS fails.
                        Only applications that are tolerant to message duplicates should use this acknowledge mode.
                     -->
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
            <!--
               Message acknowledgement: transacted - upon successful commit, auto - as soon as the message is received, lazy - automatic with possible duplicate messages.
            -->
            <xsd:attribute name="persistent" type="xsd:boolean" default="true"/>
            <!--
               True if the messages are persisted when sent.
               @detail
               Persistent messages are stored so that they can survive a failure in the messaging engine,
               when non-persistent messages can be lost.
               @category Sender
            -->
            <xsd:attribute name="priority" default="4">
               <xsd:simpleType>
                  <xsd:restriction base="xsd:unsignedByte">
                     <xsd:maxInclusive value="9"/>
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
            <!--
               Default message priority on sent messages, 0 is the lowest, 9 is the highest.
               @category Sender
            -->
            <xsd:attribute name="ttl" type="nonNegativeLong" default="0"/>
            <!--
               Default message time-to-live on sent messages in milliseconds (0 for unlimited).
               @category Sender
            -->
            <xsd:attribute name="loopback" type="xsd:boolean" default="true"/>
            <!--
               Only valid for broadcast queues (publish/subscribe topic).  True to allow processing of messages originating in the local node, false to skip them.
               @detail
               Only applicable to broadcast queues (JMS Topics).  If false, outgoing messages are tagged with a 'node' property
               unique to this server.  Incoming messages from the topic are checked for this property and are discarded
               if the message originated from this server.  If loopback is true (or the queue is P2P and not publish/subscribe),
               messages originating from this server are not filtered.  The loopback protocol is cooperative, i.e. both the sender
               and the receiver should refuse loopback messages in order to actually disable them; this is done so that one could
               deploy different metadata and change one's mind for unconsumed messages.
               @category Broadcast
            -->
            <xsd:attribute name="trusted" type="xsd:boolean" default="false"/>
            <!--
               True if the queue can pass the authenticated user information.
               @detail
               User Propagation

               When a JMS message is received, if the trusted flag is true then the
               framework will process the message as the user specified in the "user"
               JMS message property.

               When a JMS message is sent, the current user principal name is stored in
               the JMS message property "user".


               Visibility Protection Propagation

               When a JMS message is received, if the trusted flag is true then the
               framework will process the message in an invocation context for which
               the protected flag is set to the value of the "protected" JMS message
               property. If the trusted flag is false, then the invocation context's
               protected flag will be true.


               Unit of Work Property Propagation

               When a JMS message is received, if the trusted flag is true then the
               framework will add the serialized property map in the "state" JMS message
               property to the current Unit of Work. These properties are the Unit of
               Work properties from the sender Unit of Work.

               Unit of Work properties are set using the setValue and getValue methods
               on UnitOfWork.

               @category Security
            -->
            <xsd:attribute name="defaultUser" type="xsd:string"/>
            <!--
               User account for processing the queue messages.
               @category Security
            -->
            <xsd:attribute name="selector" type="xsd:string"/>
            <!--
               JMS message selector.
               @detail
               A message selector allows a JMS consumer to be more selective about the messages that it receives
               from a particular topic or queue.  It uses message properties and headers as criteria in conditional
               expressions. These expressions use Boolean logic to declare which messages should be delivered to a
               client, such as the JMSInput node.

               For comprehensive documentation of the selector, refer to the J2EE API documentation for
               the interface javax.jms.Message.
               @example
               The following demonstrates the construction of a message selector.
               It comprises an identifier, such as the JMSPriority header, or an application controlled property myProperty1.
               The selector string must specify an operator followed by a literal.

               Identifiers
               * Property or header field reference (such as JMSPriority, myProperty1)
               * The following values are not possible: NULL, TRUE, FALSE, NOT, AND, OR, BETWEEN, LIKE, IN, IS

               Operators
               AND, OR, LIKE, BETWEEN, =, <>, <,>, <=, >=, IS NULL, IS NOT NULL

               Literals
               * The two Boolean literals, TRUE and FALSE
               * Exact number literals that have no decimal point; for example, +25, -399, 40
               * Approximate number literals. These literals can use scientific notation or decimal; for example, -21.4E4, 5E2, +34.4928
               @category Receiver
            -->
            <xsd:attribute name="subscription" type="xsd:string"/>
            <!--
               Subscription name for durable broadcast (topic) subscriptions.
               @detail
               This property only applies to broadcast channels (topic) and is only applicable for
               services receiving messages.  If the channel is defined with broadcast=true and has
               a subscription name, then the subscription will be durable.

               Durability describes whether or not the server will hold onto a message if a subscriber
               is temporarily inactive. Message durability is different from message persistence.
               Durability is defined by the relationship that exists between a Topic subscriber and the
               server. A subscriber that is set up as durable will have messages sent to it held by the
               server if the subscriber is temporarily distracted doing something else or its session
               becomes inactive for some reason. Durability can only be established for the Pub/Sub (Topic)
               message model.
               @category Broadcast
            -->
            <xsd:attribute name="clientId" type="xsd:string"/>
            <!--
               Client identifier for durable broadcast (topic) subscriptions.
               @detial
               This property only applies to topics (broadcast=true).

               Although both message models use a client ID, only the Pub/Sub actually uses it. You will see a client ID for a QueueConnection, but JMS does not currently use them. Some vendors might be using client IDs for something internal to their JMS server for queues. Check with your vendor's documentation to be safe.
               @category Broadcast
            -->
            <xsd:attribute name="replyQueue" type="xsd:string"/>
            <!--
               JMS Message Queue on which the response message is expected.
               @detail
               If set, the JMSReplyTo attribute on javax.jms.Message is set to the Destination of the
               given channel. The receiving party of the JMS message then knows where to send the response,
               if any.
               The "replyQueue" attribute may be overridden at runtime by specifying the "replyTo"
               property on the message being sent.
            -->
            <xsd:attribute name="errorQueue" type="xsd:string"/>
            <!--
               Queue to which to forward the message if the processing fails.
               @category Receiver
            -->
            <xsd:attribute name="errorCount" type="nonNegativeInt" default="3"/>
            <!--
               Maximum count of attempts at transacted processing of a message before forwarding it to the error queue (0 for unlimited).
               @detail
               The error count is always 1 for auto and lazy acknowledgement.
               Unlimited error count (0) combined with transacted acknowledgement can result in
               indefinitely retried processing, which can block delivery of other messages,
               consume significant system resources and pollute the log files. This situation
               is also known as "queue poisoning".
               @category Receiver
            -->
            <xsd:attribute name="maxSenders" type="nonNegativeInt" default="16"/>
            <!--
               Maximum queue sender connections per server.
               @category Sender
            -->
            <xsd:attribute name="maxReceivers" type="nonNegativeInt" default="4"/>
            <!--
               Maximum queue receiver thread pool size per server.
               @category Receiver
            -->
            <xsd:attribute name="transactionTimeout" type="nonNegativeInt"/>
            <!--
               The timeout (in seconds) for transactions started on the J2EE component. Applies only to incoming transactional channels.
               @detail
               Set to 0 to use server default transaction timeout.
               @category Receiver
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="Mail">
      <xsd:complexContent>
         <xsd:extension base="Channel">
            <xsd:attribute name="alias" type="alias"/>
            <!--
               Alias for JNDI lookup.
            -->
            <xsd:attribute name="queue" type="xsd:string"/>
            <!--
               Message queue where to forward the received messages.
               @category Receiver
            -->
            <xsd:attribute name="defaultUser" type="xsd:string"/>
            <!--
               User account for processing the Mail messages.
               @category Security
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="HTTP">
      <xsd:complexContent>
         <xsd:extension base="Channel">
            <xsd:attribute name="url" type="xsd:string"/>
            <!--
               Default HTTP request URL.
            -->
            <xsd:attribute name="agent" type="xsd:string"/>
            <!--
               Sender User-Agent.
               @example
               user-agent: Mozilla/5.0 (Linux; X11)
            -->
            <xsd:attribute name="contentType" type="xsd:string"/>
            <!--
               The default HTTP mime type of the body of the request (used with POST and PUT requests) or response content (http request/response).
               @detail
               This header indicates the Internet media type of the message content, consisting of a type and subtype.
               @example
               Common values include:
               <pre>
               * application/x-www-form-urlencoded - use this when POSTing parameters
               * application/javascript
               * application/pdf
               * application/xhtml+xml
               * application/json
               * image/gif
               * image/jpeg
               * text/html
               * text/xml
               * text/plain
               </pre>
               see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html and http://en.wikipedia.org/wiki/Internet_media_type#List_of_common_media_types
            -->
            <xsd:attribute name="binary" type="xsd:boolean"/>
            <!--
               True if the data is binary, false if string. If unset, the data type is determined from HTTP headers for each request.
            -->
            <xsd:attribute name="error" type="xsd:string"/>
            <!--
               Expression returning non-#f if the message should be treated as an error.
               @detail
               This property is used to specify special cases that you want to handle yourself. By default anything 
               other than a status of 200 will be treated as an error. The raw message is passed as "this".
               @example
               ; accept responses with status code of OK (200) or Redirection (302) - reject all others
               (not (in? (this'status) '(200 302)))
               @category Behavior
            -->
            <xsd:attribute name="privilege" type="xsd:string"/>
            <!--
               Privilege required to access the HTTP channel receiver.
               @category Security
            -->
            <xsd:attribute name="delete" type="xsd:boolean" default="false"/>
            <!--
               True if the HTTP DELETE method is implemented.
               @category Behavior
            -->
            <xsd:attribute name="get" type="xsd:boolean" default="false"/>
            <!--
               True if the HTTP GET method is implemented.
               @category Behavior
            -->
            <xsd:attribute name="head" type="xsd:boolean" default="false"/>
            <!--
               True if the HTTP HEAD method is implemented.
               @category Behavior
            -->
            <xsd:attribute name="options" type="xsd:boolean" default="false"/>
            <!--
               True if the HTTP OPTIONS method is implemented.
               @category Behavior
            -->
            <xsd:attribute name="post" type="xsd:boolean" default="true"/>
            <!--
               True if the HTTP POST method is implemented.
               @category Behavior
            -->
            <xsd:attribute name="put" type="xsd:boolean" default="false"/>
            <!--
               True if the HTTP PUT method is implemented.
               @category Behavior
            -->
            <xsd:attribute name="trace" type="xsd:boolean" default="false"/>
            <!--
               True if the HTTP TRACE method is implemented.
               @category Behavior
            -->
            <xsd:attribute name="readTimeout" type="nonNegativeInt" default="0"/>
            <!--
               Timeout in milliseconds for outbound HTTP requests, 0 for infinite timeout.
               @category Behavior
            -->
            <xsd:attribute name="connectionTimeout" type="nonNegativeInt" default="60000"/>
            <!--
               Timeout in milliseconds for establishing HTTP connections, 0 for infinite timeout.
               @category Behavior
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="UDP">
      <xsd:complexContent>
         <xsd:extension base="Channel">
            <xsd:attribute name="encoding" type="xsd:string"/>
            <!--
               Character encoding for string messages. If not specified, the messages are binary.
            -->
            <xsd:attribute name="port" type="xsd:unsignedShort"/>
            <!--
               Remote UDP port.
            -->
            <xsd:attribute name="localPort" type="xsd:unsignedShort"/>
            <!--
               Local UDP port (0 or empty for a random port).
            -->
            <xsd:attribute name="group" type="xsd:string"/>
            <!--
               Multicast group IP address.
               @category Receiver
            -->
            <xsd:attribute name="ttl" type="xsd:unsignedByte" default="128"/>
            <!--
               Packet time-to-live in hops (0..255).
               @category Sender
            -->
            <xsd:attribute name="tos" type="xsd:unsignedByte" default="0"/>
            <!--
               RFC 1349 type-of-service value (sum of lowCost=2, reliability=4, throughput=8, lowDelay=16).
               @category Sender
            -->
            <xsd:attribute name="maxPacketSize" type="positiveUnsignedShort" default="8192"/>
            <!--
               Maximum received packet size in bytes.
               @category Receiver
            -->
            <xsd:attribute name="maxSenders" type="nonNegativeInt" default="16"/>
            <!--
               Maximum UDP sender connection pool size per server.
               @category Sender
            -->
            <xsd:attribute name="maxReceivers" type="nonNegativeInt" default="4"/>
            <!--
               Maximum UDP receiver thread pool size per server.
               @category Receiver
            -->
            <xsd:attribute name="queue" type="xsd:string"/>
            <!--
               Message queue where to forward the received messages.
               @category Receiver
            -->
            <xsd:attribute name="defaultUser" type="xsd:string"/>
            <!--
               User account for processing the UDP messages.
               @category Security
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>
   
   <xsd:complexType name="ObjectQueue">
      <xsd:complexContent>
         <xsd:extension base="Channel">
            <xsd:attribute name="class" type="identifier"/>
            <!--
               ObjectQueue implementation.  Defaults to SysObjectQueue.
               @category Common
            -->
            <xsd:attribute name="priority" type="xsd:int"/>
            <!--
               The relative priority of this queue.
               @category Receiver
            -->
            <xsd:attribute name="concurrency" type="nonNegativeInt"/>
            <!--
               The maximum number of messages that may be processed concurrently from this queue.
               @category Receiver
            -->
            <xsd:attribute name="rate" type="nonNegativeDouble"/>
            <!--
               The maximum number of messages that may be processed concurrently from this queue in one minute.
               @category Receiver
            -->
            <xsd:attribute name="timeout" type="nonNegativeInt"/>
            <!--
               The unit of work timeout in milliseconds for message processing.  The transaction timeout will automatically be set to double this value.
               A value of zero indicates an infinite timeout.
               @category Receiver
            -->
            <xsd:attribute name="errorCount" type="nonNegativeInt"/>
            <!--
               The number of times a message can fail before it is forwarded to the errorQueue, or deleted if no errorQueue is specified.
               @category Receiver
            -->
            <xsd:attribute name="errorQueue" type="xsd:string"/>
            <!--
               The name of the queue to which to send messages that fail to deliver on this queue.
               @category Receiver
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>
   
   <xsd:complexType name="TCP">
      <xsd:complexContent>
         <xsd:extension base="Channel">
            <xsd:attribute name="encoding" type="xsd:string"/>
            <!--
               Character encoding for string messages. If not specified, the messages are binary.
            -->
            <xsd:attribute name="remotePort" type="positiveUnsignedShort"/>
            <!--
               Remote TCP port.
            -->
            <xsd:attribute name="localPort" type="xsd:unsignedShort"/>
            <!--
               Local TCP port (0 or empty for a random port).
            -->
            <xsd:attribute name="localHost" type="xsd:string"/>
            <!--
               Local hostname or IP address to listen on.  If not specified, then "localhost".
            -->
            <xsd:attribute name="queue" type="identifier"/>
            <!--
               Message queue where to forward the received messages.
               @category Receiver
            -->
            <xsd:attribute name="defaultUser" type="xsd:string"/>
            <!--
               User account for processing the TCP messages.
               @category Security
            -->
            <xsd:attribute name="resolve" type="xsd:boolean" default="false"/>
            <!--
               True to resolve ip addresses to hostnames.
               @category Receiver
            -->
            <xsd:attribute name="splitter" type="xsd:string"/>
            <!--
               The name of the associated message stream factory component.
            -->
            <xsd:attribute name="backlog" type="nonNegativeInt" default="5"/>
            <!--
               The server backlog size (the maximum number of pending connections
               that are waiting to be accepted by the listener).
               If the value is 0, then the system default value will be used. 
               @category Receiver
            -->
            <xsd:attribute name="readTimeout" type="nonNegativeInt"/>
            <!--
               The message read timeout in milliseconds.
               This is the maximum time the channel will block while in the
               process of receiving a message. If a timeout occurs, a
               nexj.core.rpc.tcp.ra.TCPTimeoutException will be raised.
               A value of zero indicates an infinite timeout.
               @category Receiver
            -->
            <xsd:attribute name="secure" type="xsd:boolean" default="false"/>
            <!--
               True if this channel should use SSL/TLS.
               
               @category Security
            -->
            <xsd:attribute name="idleTimeout" type="nonNegativeInt" default="0"/>
            <!--
               The number of minutes this channel will be allowed to remain inactive
               before it is forcibly closed.
               A value of zero indicates an infinite limit.
               
               This timeout only applies to inactivity between messages. For inactivity
               while receiving a message, refer to the "readTimeout" property.
               
               @category Receiver
            -->
            <xsd:attribute name="keepAlive" type="xsd:boolean" default="false"/>
            <!--
               True if the TCP keep-alive property should be set on the underlying socket.
               
               @category Receiver
            -->
            <xsd:attribute name="connectionTimeout" type="nonNegativeInt" default="60000"/>
            <!--
               Timeout in milliseconds for establishing TCP connections, 0 for infinite timeout.
               
               @category Sender
            -->
            <xsd:attribute name="noDelay" type="xsd:boolean" default="false"/>
            <!--
               True if the TCP no-delay property should be set on the underlying socket.
            -->
            <xsd:attribute name="maxSenders" type="nonNegativeInt" default="16"/>
            <!--
               Maximum TCP sender connection pool size per server.
               @category Sender
            -->
            <xsd:attribute name="maxReceivers" type="nonNegativeInt" default="4"/>
            <!--
               Maximum TCP receiver thread pool size per server.
               @category Receiver
            -->
            <xsd:attribute name="senderBufferSize" type="nonNegativeInt" default="0"/>
            <!--
               The SO_SNDBUF option for the underlying socket, 0 for system default.
            -->
            <xsd:attribute name="receiverBufferSize" type="nonNegativeInt" default="0"/>
            <!--
               The SO_RCVBUF option for the underlying socket, 0 for system default.
            -->
            <xsd:attribute name="tos" type="xsd:unsignedByte" default="0"/>
            <!--
               RFC 1349 type-of-service value (sum of lowCost=2, reliability=4, throughput=8, lowDelay=16).
               @category Sender
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="FileChannel">
      <xsd:complexContent>
         <xsd:extension base="Channel">
            <xsd:attribute name="encoding" type="xsd:string"/>
            <!--
               The Java charset to use for encoding/decoding character data from the file. Leave unspecified for binary mode.
               @detail
               These are the charsets available on every implementation of the Java platform:

               US-ASCII:   Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set
               ISO-8859-1: ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1
               UTF-8:      Eight-bit UCS Transformation Format
               UTF-16BE:   Sixteen-bit UCS Transformation Format, big-endian byte order (when decoding, ignore BOM; when encoding, do not write BOM)
               UTF-16LE:   Sixteen-bit UCS Transformation Format, little-endian byte order (when decoding, ignore BOM; when encoding, do not write BOM)
               UTF-16:     Sixteen-bit UCS Transformation Format, byte order identified by an optional byte-order mark. (when decoding, interpret BOM, defaulting to big-ending if no BOM; when encoding, use big-endian and write big-endian BOM)

               Charset names are not case-sensitive.

               UTF-8 files may begin with a BOM (byte-order mark). When the channel is configured to use UTF-8 encoding, it will
               automatically ignore a leading BOM for input. On UTF-8 output, the channel will never generate such a BOM.
            -->
            <xsd:attribute name="processedName" type="xsd:string" default="${orig}_${ts}"/>
            <!--
               The template to use for generating a new name for incoming files after they have been processed. (Timestamp: ${ts}, Sequence number: ${seq}, Original path: ${orig}, GUID: ${guid})

               @detail
               ${ts} - Timestamp in milliseconds
               ${seq} - Sequence number
               ${guid} - GUID
               ${orig} - The original file path, relative to the incoming directory
               ${origName} - The original file name
               @category Receiver
            -->
            <xsd:attribute name="outgoingName" type="xsd:string" default="${ts}_${seq}"/>
            <!--
               The template to use for automatically generating outgoing message file names. (Timestamp: ${ts}, Sequence number: ${seq}, GUID: ${guid})

               @detail
               ${ts} - Timestamp in milliseconds
               ${seq} - Sequence number
               ${guid} - GUID
               @category Sender
            -->
            <xsd:attribute name="defaultUser" type="xsd:string"/>
            <!--
               User account for processing the file messages.
               @category Security
            -->
            <xsd:attribute name="transactionTimeout" type="nonNegativeInt"/>
            <!--
               The timeout (in seconds) for transactions started on the J2EE component. Applies only to incoming transactional channels.
               @detail
               Set to 0 to use server default transaction timeout.
               @category Receiver
            -->
            <xsd:attribute name="maxSenders" type="nonNegativeInt" default="16"/>
            <!--
               Maximum file sender connection pool size per server.
               @category Sender
            -->
            <xsd:attribute name="maxReceivers" type="nonNegativeInt" default="4"/>
            <!--
               Maximum file receiver thread pool size per server.
               @category Receiver
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="GenericChannel">
      <xsd:complexContent>
         <xsd:extension base="Channel">
            <xsd:sequence>
               <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
            </xsd:sequence>
            <xsd:attribute name="type" type="xsd:string" use="required"/>
            <!--
               Channel type.
            -->
            <xsd:anyAttribute processContents="lax"/>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="ChannelConnection">
      <xsd:annotation>
         <xsd:appinfo>
            <Collection key="channel"/>
         </xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="channel" type="xsd:string" use="required"/>
      <!--
         Connection channel.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Channel connection description.
      -->
   </xsd:complexType>

   <xsd:complexType name="Format">
   <!--
      A Message's Format specifies how the Message will be marshalled between internal canonical and external represtenation.
      @detail
      Currently supported format's include:
      <pre>
      * CSV (CSVMapping) - comma separated value
      * Fixed (FixedMapping) - fixed-length fields ("flat file") format
      * HL7 (HL7Mapping) - health level 7 format
      * Object (ObjectMapping) - the message is mapped to an internal class.
      * vCard (vCardMapping) - standard for electronic business cards.
      * XML (XMLMapping-Message)- XML mappings with optional SOAP support. The adapter knows based on the definition how to deal with soap envelopes, actions, namespace alias and the actual namespace uri for different parts.
      * Zip (ZipMapping) - represents a zip file archive.
      * JSON - represents a JSON value
      </pre>
      @context Message
   -->
      <xsd:sequence>
         <xsd:element name="Parser" type="Component" minOccurs="0" maxOccurs="1"/>
         <xsd:element name="Formatter" type="Component" minOccurs="0" maxOccurs="1"/>
      </xsd:sequence>
      <xsd:attribute name="element" type="identifier" use="required"/>
      <!--
         Mapping XML element name.
      -->
      <xsd:attribute name="loader" type="qualJavaName" use="required"/>
      <!--
         Mapping loader Java class, implementing the XMLMessageMappingLoader interface.
      -->
      <xsd:attribute name="exporter" type="qualJavaName"/>
      <!--
         Mapping exporter Java class, implementing the XMLMessageMappingExporter interface.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Format description.
      -->
   </xsd:complexType>

   <xsd:complexType name="Formats">
      <xsd:sequence>
         <xsd:element name="Format" minOccurs="0" maxOccurs="unbounded">
          <!--
              @context Extends Format
          -->
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Format">
                     <xsd:attribute name="name" type="xsd:string" use="required"/>
                     <!--
                        Format name.
                     -->
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>

   <xsd:complexType name="Message">
      <xsd:complexContent>
         <xsd:extension base="BaseMessage">
            <xsd:sequence>
               <xsd:element name="Parts" minOccurs="0" maxOccurs="1">
               <!--
                  A message is represented internally (in canonical form) as a tree of parts.
                  @detail
                  The message root's child parts are either messages (composite parts that
                  may have more child parts) or values (primitive parts - string, integer, date, ...).
                  The child parts share the mapping format of the root part.

                  The message's root part and any composite parts (messages) may have a parts collection.
                  Primitive parts (values) don't have a parts collection.
                  @context Message
               -->
                  <xsd:complexType>
                     <xsd:choice minOccurs="0" maxOccurs="unbounded">
                        <xsd:element name="Value">
                        <!--
                           A value (or primitive) message part.
                           @detail
                           A value message part is also known as a primitive message part.  It has a primitive
                           type, such as string, integer, date, ...  It shares it's format type with
                           the message's root part but it has its own mapping that defines how it
                           is marshalled between internal and external format.  Values cannot have
                           child message parts.
                           @context Message Part
                        -->
                           <xsd:complexType>
                              <xsd:complexContent>
                                 <xsd:extension base="BaseMessage">
                                    <xsd:sequence>
                                       <xsd:element name="Enumerations" minOccurs="0" maxOccurs="1">
                                       <!--
                                          Value message parts may have enumerations defining a list of values that the part can take.
                                          @detail
                                          Value message parts may have enumerations defining a list of values that the part can take.
                                          @context Message
                                       -->
                                          <xsd:complexType>
                                             <xsd:sequence>
                                                <xsd:element name="Enumeration" minOccurs="1" maxOccurs="unbounded">
                                                <!--
                                                   A list of possible string values that the value message part can take.
                                                   @context Message
                                                -->
                                                   <xsd:complexType>
                                                      <xsd:attribute name="value" type="xsd:string" use="required"/>
                                                      <!--
                                                         Enumeration value, one of the possible values that the message value can take.
                                                      -->
                                                      <xsd:attribute name="description" type="xsd:string"/>
                                                      <!--
                                                         Enumeration value description.
                                                      -->
                                                   </xsd:complexType>
                                                </xsd:element>
                                             </xsd:sequence>
                                             <xsd:attribute name="lax" type="xsd:boolean" default="false"/>
                                          </xsd:complexType>
                                       </xsd:element>
                                    </xsd:sequence>
                                    <xsd:attribute name="name" type="messagePartIdentifier" use="required"/>
                                    <!--
                                       Part name, unique within the parent part.
                                    -->
                                    <xsd:attribute name="minCount" type="nonNegativeInt" default="0"/>
                                    <!--
                                       Minimum count of occurences of this part.
                                    -->
                                    <xsd:attribute name="maxCount" type="nonNegativeInt" default="1"/>
                                    <!--
                                       Maximum count of occurrences of this part (0 for unlimited).
                                    -->
                                    <xsd:attribute name="type" type="primitiveType" use="required"/>
                                    <!--
                                       Value part type.
                                    -->
                                 </xsd:extension>
                              </xsd:complexContent>
                           </xsd:complexType>
                        </xsd:element>
                        <xsd:element name="Message">
                        <!--
                           A message (or composite) message part.
                           @detail
                           A message part is also known as a composite message part.  It is a sub-message
                           that can have it's own child parts.  It shares it's format type with
                           the message's root part but it has its own mapping that defines how it
                           is marshalled between internal and external format.
                           @context Message Part
                        -->
                           <xsd:complexType>
                              <xsd:complexContent>
                                 <xsd:extension base="Message">
                                    <xsd:attribute name="name" type="messagePartIdentifier" use="required"/>
                                    <!--
                                       Part name, unique within the parent part.
                                    -->
                                    <xsd:attribute name="minCount" type="nonNegativeInt" default="0"/>
                                    <!--
                                       Minimum count of occurences of this part.
                                    -->
                                    <xsd:attribute name="maxCount" type="nonNegativeInt" default="1"/>
                                    <!--
                                       Maximum count of occurrences of this part (0 for unlimited).
                                    -->
                                 </xsd:extension>
                              </xsd:complexContent>
                           </xsd:complexType>
                        </xsd:element>
                     </xsd:choice>
                  </xsd:complexType>
               </xsd:element>
            </xsd:sequence>
            <xsd:attribute name="aggregation" default="sequential">
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:enumeration value="sequential"/>
                     <!--
                        The contained parts must appear in their order of declaration.
                     -->
                     <xsd:enumeration value="random"/>
                     <!--
                        The contained parts may appear in any order.
                     -->
                     <xsd:enumeration value="single"/>
                     <!--
                        Only one of the contained parts may appear.  This implies a 'choice'.
                     -->
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
            <!--
               Child part aggregation mode.
               @detail
               Child parts must appear in the order specified (sequential), in any
               order (random) or only one choice of the children may appear (single).

               When "ref" is set, the aggregation from the referenced message part is used and the
               aggregation on the reference is ignored.
            -->
            <xsd:attribute name="lax" type="xsd:boolean" default="false"/>
            <!--
               True to allow and ignore unidentifiable child parts in a raw message when parsing.
               @detail
               Lax is mainly used during message parsing.  Set it to true to allow and ignore
               unidentifiable child parts in a raw message when parsing.
               If lax is false - the default - the parser will throw an error if it encounters
               a message part that is not in the message definition, like an extra XML attribute
               or a CSV column.

               When "ref" is set, the lax setting from the referenced message part is used and the
               lax setting on the reference is ignored.
               @example
               For an RSS message definition, you probably want to set the root tag
               to "lax" as most RSS feeds have custom attributes added to their XML.  If
               a custom attribute was found in a message that your message definition
               didn't expect and the "lax" flag was false, the message would be rejected.
            -->
            <xsd:attribute name="ref" type="xsd:string"/>
            <!--
               Message defining this part (and any subparts).
               @detail
               If the ref is set to another message name, then this part will be defined
               by the structure of that message.
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="BaseMessage">
      <xsd:sequence>
         <xsd:choice minOccurs="0" maxOccurs="1">
            <xsd:element name="ObjectMapping">
            <!--
               Maps message parts to attributes in class instances.
            -->
               <xsd:complexType>
                  <xsd:attribute name="attribute">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:pattern value="[\p{L}_][\p{L}\p{N}_]*|:[\p{L}_][\p{L}\p{N}_-]*"/>
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     Attribute to which the part is mapped.
                  -->
                  <xsd:attribute name="class" type="identifier"/>
                  <!--
                     Class to which the part is mapped.
                  -->
                  <xsd:attribute name="key" type="xsd:boolean" default="false"/>
                  <!--
                     True if the value is used as lookup key for the parent part instance.
                  -->
                  <xsd:attribute name="subkey" type="xsd:boolean" default="false"/>
                  <!--
                     True if the value is used as a lookup key for the parent part instance, which in turn is a lookup key for the grand-parent part instance.
                  -->
                  <xsd:attribute name="local" type="xsd:boolean"/>
                  <!--
                     True to lookup the instance only within the subcollection scoped by the parent part instance. Defaults to the opposite of the "key" flag.
                  -->
                  <xsd:attribute name="where" type="xsd:string"/>
                  <!--
                     Additional lookup where clause.
                  -->
                  <xsd:attribute name="create" type="xsd:boolean" default="true"/>
                  <!--
                     True to create a missing instance, false to generate an error.
                  -->
                  <xsd:attribute name="update" type="xsd:boolean" default="true"/>
                  <!--
                     If false, the underlying attribute will not be updated on an already existing instance.
                  -->
                  <xsd:attribute name="delete" type="xsd:boolean" default="false"/>
                  <!--
                     If true, all unmatched instances of the underlying collection attribute will be deleted
                  -->
                  <xsd:attribute name="access" type="identifier"/>
                  <!--
                     Update access attribute. If its value is false, the update to the attribute or (or the whole instance for a root part) will be skipped.
                  -->
                  <xsd:attribute name="truncate" type="xsd:boolean" default="false"/>
                  <!--
                     If true, the underlying attribute value will be truncated to fit within the maximum length.
                  -->
                  <xsd:attribute name="associationCode" type="xsd:string"/>
                  <!--
                     The association code identifies child transfer objects.
                  -->
                  <xsd:attribute name="primary" type="xsd:boolean" default="true"/>
                  <!--
                     True if this message is the primary message in the hierarchy for a given class.
                     @detail
                     A hierarchy of messages can contain multiple messages with the same class.
                     If this is the case, when selecting a message to use to parse a
                     given class, the primary flag serves to disambiguate which message
                     should be used.
                     Valid only on mapping on message root.
                  -->
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="FixedMapping">
               <!--
                  Maps message parts to record fields in a fixed length file, or flat file database.
                  @detail
                  Data in fields must be padded to the field's width, and any defined prefix or suffix values must be provided.
                  Behavior is undefined for truncated records/fields, including the final record.

                  @context Message
               -->
               <xsd:complexType>
                  <xsd:attribute name="width" type="positiveInt"/>
                  <!--
                     The length, in characters, of this part (record or field).
                  -->
                  <xsd:attribute name="padding" type="xsd:string" default=" "/>
                  <!--
                     The character used for padding the remainder of the field beyond the provided data.
                  -->
                  <xsd:attribute name="alignment" default="left">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:enumeration value="left"/>
                           <xsd:enumeration value="right"/>
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     The side of the field to which data is aligned.

                     For example, left alignment means that if the data's length is less than the field's
                     width, the remainder of the width is filled with the padding characters to the right of the data.
                  -->
                  <xsd:attribute name="prefix" type="xsd:string"/>
                  <!--
                     A prefix string at the start of the at the end of the message root, record part or field part that is
                     stripped out during parsing, or prefixed to the field or record when formatting.

                     Typically this value is unused not set (unused) by fixed length messages. If set, every
                     instance of the record part or field part must include the prefix string. Currently during
                     parsing, the number of prefix characters are stripped from the incoming data but the
                     stripped characters are not compared to this prefix value. '\' is an escape character;
                     e.g. "\n" is a newline character, "\\" is a slash '\', "\u005c" is a unicode character.
                  -->
                  <xsd:attribute name="suffix" type="xsd:string"/>
                  <!--
                     A suffix string at the end of a record part or field part that is stripped out during
                     parsing, or appended to the very end of the field or record when formatting.  It is invalid to have
                     a suffix on a message root.

                     Typically this value is not set (unused) by fixed length fields. If set, every instance of
                     the record part or field part must include the suffix string. Currently during parsing, the
                     number of suffix characters are stripped from the incoming data but the stripped
                     characters are not compared to this suffix value. '\' is an escape character;
                     e.g. "\n" is a newline character, "\\" is a slash '\', "\u005c" is a unicode character.
                  -->
                  <xsd:attribute name="format" type="xsd:string"/>
                  <!--
                     Format string to be used when formatting the value.
                     @detail
                     This property only applies to value message parts and is not to be confused with
                     the format property of the root message part.  It is used to format primitive
                     values to a specific external representation.

                     For timestamp formats see the SimpleDateFormat Java class.

                     For decimal, double, float, integer, and long formats see the DecimalFormat Java class.

                     For boolean formats we use our own formatter that supports the following values.  "Yes,True,#t;No,False,#f"
                     @note
                     <pre>
                     * the timezone from the current invocation context is used.
                     * Decimal formatting symbols from the current locale are used
                       (e.g. period or space for thousands separator, etc.)
                     * The format pattern is presumed to be a string id and is looked up in
                       the strings for the current invocation context. If not found, a second lookup
                       is attempted, prefixing the format pattern with "ids.format.". If that
                       also fails, then the format pattern is assumed to contain a format pattern
                       that can be passed directly to the format instance.
                     </pre>
                     @example
                     "h:mm a" => "12:08 PM"
                     "EEE, d MMM yyyy HH:mm:ss Z" => "Wed, 4 Jul 2001 12:08:56 -0700"
                     "#,##0.0#;(#,##0.0#)" => "1,000.0"
                  -->
                  <xsd:attribute name="pageSize" type="nonNegativeInt" default="0"/>
                  <!--
                     Set this to swap data to disk if the page size (in elements) is exceeded. Zero to disable paging.
                     @detail
                     Applies only on the collection part.
                  -->
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="JSONMapping">
               <!--
                  Maps message parts to JSON objects, arrays or primitives.
                  @detail
                  Composite message parts may be mapped to JSON object, array or root for structure.
   
                  @context Message
               -->
               <xsd:complexType>
                  <xsd:attribute name="subtype" default="">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:enumeration value=""/>
                           <xsd:enumeration value="array"/>
                           <xsd:enumeration value="root"/>
                           <xsd:enumeration value="dateTime"/>
                           <xsd:enumeration value="date"/>
                           <xsd:enumeration value="time"/>
                           <xsd:enumeration value="base64"/>
                           <xsd:enumeration value="hex"/>
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     Message and primitive subtype.
                     @detail
                     For message subtypes, you may specify array or root. 

                     1. Object subtype is the default and it begins with { and ends with }.

                     2. Array subtype which begins with [ and ends with ].

                     3. Root subtype.
                        There can be only one child message part of root.

                     For value subtypes:
                     1. On timestamp type values, you may specify a subtype of date, time or datetime.

                     2. On binary type values, you may specify a subtype of base64 or hex.
                  -->
                  <xsd:attribute name="format" type="xsd:string"/>
                  <!--
                     Format string to be used when formatting the value.
                     @detail
                     For timestamp formats see the SimpleDateFormat Java class.
   
                     For decimal, double, float, integer, and long formats see the DecimalFormat Java class.
   
                     For boolean formats we use our own formatter that supports the following values.  "Yes,True,#t;No,False,#f"
                     @note
                     <pre>
                     * the timezone from the current invocation context is used.
                     * Decimal formatting symbols from the current locale are used
                       (e.g. period or space for thousands separator, etc.)
                     * The format pattern is presumed to be a string id and is looked up in
                       the strings for the current invocation context. If not found, a second lookup
                       is attempted, prefixing the format pattern with "ids.format.". If that
                       also fails, then the format pattern is assumed to contain a format pattern
                       that can be passed directly to the format instance.
                     </pre>
                     @example
                     "h:mm a" => "12:08 PM"
                     "EEE, d MMM yyyy HH:mm:ss Z" => "Wed, 4 Jul 2001 12:08:56 -0700"
                     "#,##0.0#;(#,##0.0#)" => "1,000.0"
                  -->
                  <xsd:attribute name="name" type="xsd:string"/>
                  <!--
                     The name to use for this part in the JSON message. Defaults to the message part name.
                  -->
                  <xsd:attribute name="key">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:pattern value="[^:]+:[^:]+"/>
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     The unique JSON object "key:value" combination to identify a message in a message table.
                  -->
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="HL7Mapping">
               <!--
                  Maps message parts to segments and fields in a Health Level Seven (HL7), v2.x file.
                  @detail
                  HL7 Version 2.x defines a series of electronic messages to support administrative,
                  logistical, financial as well as clinical processes. Since 1987 the standard has been updated
                  regularly, resulting in versions 2.1, 2.2, 2.3, 2.3.1, 2.4, 2.5, 2.5.1 and 2.6.
                  Collectively these versions are known as version 2.x. The v2.x standards are backwards compatible,
                  i.e. a message based on version 2.3 will be understood by an application that supports version 2.6.

                  HL7 v2.x mostly uses a textual, non-XML encoding syntax based on delimiters.  A sample follows:

                  <pre>
                  MSH|^~\|Meg|Xyz|Sub|XyzI|20060529090131-0500||ADT^A01|0105|P|2.5
                  EVN||200605290901||||200605290900
                  PID|||567^^^UA^PI||KIM^JOE^Q^JR||19620910|M||2028-9^^HL70005^RA99113^^...
                  ...
                  </pre>

                  Each segment (row) in a message has an identifying tag, such as MSH or PID, followed by some number of fields and sub-fields
                  that are arranged by position.

                  The root part of the message must be mapped to the name of the message.  e.g. To map the example message
                  above, the name of the mapping on the root part should be ADT^A01.

                  Each message has a special header segment that contains control information. The header's tag is MSH.  If the
                  message has no message part mapped to MSH, the header will still be processed and defaults will
                  be used.  If there is a part mapped to MSH, the header fields may be accessed or set through
                  the message. A sample MSH message structure is available in the message HL7_base.

                  See the "name", "seq" and "subtype" properties for more information on mapping.

                  Grouping:
                  Non-mapped message parts may be used for grouping segments.  When representing a complex structure,
                  you may use a non-mapped collection part to represent the group.  Set the unmapped part to be
                  a collection (ie. 0..0) to represent repeating groups.  Non-mapped parts may be nested to an arbitrary
                  level.
                  e.g. if we have a structure like
                  <pre>
                               MSG|...
                               PID|...
                               G1|... (repeating group)
                               P1|...
                               P1|...
                               P1|...
                               G1|... (repeating group)
                               P1|...
                               ...

                     We may define a message structure as:
                     ADT1       (mapped to ADT^A01)
                        PID     (mapped to PID)
                        G1Group (collection - not mapped)
                           G1   (mapped to G1)
                           P1   (collection - mapped to P1)
                  </pre>

                  Message Reuse:
                  HL7 messages support message inheritance and reuse as described in the Message (Root Message) "base"
                  and Message (Message Part) "ref" property.  The level of the reusable message depends on its root mapping:
                  no mapping implies group,
                  name and seq implies segment,
                  seq only implies field.

                  "z" segments and the "lax" property:
                  To ignore unexpected "z" segments set the lax property on any parent message part under which you may
                  encounter them. For information on the "lax" property see the Message (Message Part) "lax"
                  property - (Root Part) as well.  For information on "z" segments, see
                  http://www.hl7standards.com/blog/2006/10/05/what-are-z-segments/.
                  @context Message
               -->
               <xsd:complexType>
                  <xsd:attribute name="name" type="xsd:string"/>
                  <!--
                     HL7 segment name.
                     @detail
                     Set the name property to the identifying tag of the segment.  Along with the segment name,
                     the number of fields in the segment must be indicated in the "seq" property to create
                     proper outbound messages.

                     Segments will be output in the order in which they are defined in the message.
                     @example
                     MSH
                     PID
                     EVN
                  -->
                  <xsd:attribute name="seq" type="positiveInt"/>
                  <!--
                     HL7 field sequential number.
                     @detail
                     If the segment "name" property is set the number of fields in the segment must be
                     indicated in the "seq" property to create proper outbound messages.

                     On fields set the "seq" property to the position within it's parent segment or field.
                  -->
                  <xsd:attribute name="subtype">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:enumeration value="DTM"/>
                           <!--
                              Time Stamp (Date &amp; Time)
                           -->
                           <xsd:enumeration value="DT"/>
                           <!--
                              Date
                           -->
                           <xsd:enumeration value="TM"/>
                           <!--
                              Time
                           -->
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     Value Subtype.  On timestamp type values, you may specify a subtype of date, time or datetime.
                  -->
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="CSVMapping">
               <!--
                  Maps message parts to columns in a CSV file.
                  @detail
                  Requires a "rows" composite message part with child value parts representing columns in the CSV record.
               -->
               <xsd:complexType>
                  <xsd:attribute name="field" type="xsd:string"/>
                  <!--
                     CSV field name to which this value should be mapped.
                     @detail
                     'Field' is only needed if 'header' is set to true.  If 'field' is not specified, then the message part value name will be used.
                  -->
                  <xsd:attribute name="ordinal" type="positiveInt"/>
                  <!--
                     The 1-based index of the field in the CSV file to which this value should map.
                     @detail
                     'Ordinal' will be used to order the fields on output.  Default ordering is determined by the message structure (i.e. the order of the message part values).  'Ordinal' allows you to re-order the output message.  'Ordinal' also determines which column to map to the message part value on input when 'header' is set to false.  If 'header' is set to true, 'ordinal' is ignored on input (but not on output as stated above).
                  -->
                  <xsd:attribute name="comment" type="xsd:string" default=""/>
                  <!--
                     Lines starting with one of these characters should be ignored by the parser.

                     @category CSV Format
                  -->
                  <xsd:attribute name="delimiter" type="xsd:string"/>
                  <!--
                     The character to use as the CSV field delimiter. (Default value: ',') Special characters supported through backslash escaping.

                     @category CSV Format
                  -->
                  <xsd:attribute name="escape" type="xsd:string"/>
                  <!--
                     A character used to prefix special characters in the data;
                     "none" to disable escaping altogether. (Default value: '\')
                     @detail
                     'Quote' and 'escape' have a special relationship as follows:
                     - If 'quote' is set and 'escape' is "none" the 'quote' character will be escaped by 'doubling-up' the character.  (e.g. 'she said "hi"' will be escaped as "she said ""hi""")
                     - If 'quote' is set and 'escape' is set the 'quote' character will be escaped by the escape character.  (e.g. 'she said "hi"' will be escaped as "she said \"hi\"")
                     - If 'quote' is "none" and 'escape' is set the 'delimiter' character can be escaped, but newlines cannot be escaped and may confuse parsing (not recommended).
                     - If 'quote' and 'escape' are both set to "none" then it is possible to produce ambiguous output.
                     @category CSV Format
                  -->
                  <xsd:attribute name="quote" type="xsd:string"/>
                 <!--
                    A character used to quote fields which contain special characters;
                    "none" to disable quoting altogether. (Default value: '"')
                     @detail
                     'Quote' and 'escape' have a special relationship as follows:
                     - If 'quote' is set and 'escape' is "none" the 'quote' character will be escaped by 'doubling-up' the character.  (e.g. 'she said "hi"' will be escaped as "she said ""hi""")
                     - If 'quote' is set and 'escape' is set the 'quote' character will be escaped by the escape character.  (e.g. 'she said "hi"' will be escaped as "she said \"hi\"")
                     - If 'quote' is "none" and 'escape' is set the 'delimiter' character can be escaped, but newlines cannot be escaped and may confuse parsing (not recommended).
                     - If 'quote' and 'escape' are both set to "none" then it is possible to produce ambiguous output.
                     @category CSV Format
                  -->
                  <xsd:attribute name="line" default="\n">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:enumeration value="\n"/>
                           <xsd:enumeration value="\r"/>
                           <xsd:enumeration value="\r\n"/>
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     The end-of-line sequence to output after every record when formatting.

                     @category CSV Format
                  -->
                  <xsd:attribute name="quoted" type="xsd:boolean"/>
                  <!--
                     Force formatter to quote this field. Overrides value inherited from parent. If false or
                     unspecified, then only quote as necessary.
                     @detail
                     'Quoted' is only relevant during output.
                     By default, we employ 'minimal quoting'.  Only field values that need quoting (i.e. contain special characters) will be quoted on output.  By setting 'quoted' to true on a message part value, the field will be quoted unconditionally on output regardless of the value.
                     @category CSV Format
                  -->
                  <xsd:attribute name="header" type="xsd:boolean" default="true"/>
                  <!--
                     True to output a header row of field names.

                     @category CSV Format
                  -->
                  <xsd:attribute name="pageSize" type="nonNegativeInt" default="0"/>
                  <!--
                     Set this to swap data to disk if the page size (in elements) is exceeded. Zero to disable paging.
                  -->
                  <xsd:attribute name="format" type="xsd:string"/>
                  <!--
                     Format string to be used when formatting the value.
                     @detail
                     This property only applies to value message parts and is not to be confused with
                     the format property of the root message part.  It is used to format primitive
                     values to a specific external representation.

                     For timestamp formats see the SimpleDateFormat Java class.

                     For decimal, double, float, integer, and long formats see the DecimalFormat Java class.

                     For boolean formats we use our own formatter that supports the following values.  "Yes,True,#t;No,False,#f"
                     @note
                     <pre>
                     * the timezone from the current invocation context is used.
                     * Decimal formatting symbols from the current locale are used
                       (e.g. period or space for thousands separator, etc.)
                     * The format pattern is presumed to be a string id and is looked up in
                       the strings for the current invocation context. If not found, a second lookup
                       is attempted, prefixing the format pattern with "ids.format.". If that
                       also fails, then the format pattern is assumed to contain a format pattern
                       that can be passed directly to the format instance.
                     </pre>
                     @example
                     "h:mm a" => "12:08 PM"
                     "EEE, d MMM yyyy HH:mm:ss Z" => "Wed, 4 Jul 2001 12:08:56 -0700"
                     "#,##0.0#;(#,##0.0#)" => "1,000.0"
                  -->
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="XMLMapping">
            <!--
               Maps message parts to XML elements, attributes or values.
               @detail
               The root part allows you to specify important XML characteristics of the overall message,
               such as whether to wrap the xml message in a soap envelope (either 1.1 or 1.2).

               Composite message parts may be mapped to XML elements for structure.

               Primitive message parts, or values, may be mapped to XML elements, attributes or values.

               Soap header support is provided and documented in the envelope property.

               The parser supports XMLSchema 1.0.
               @context Message
            -->
               <xsd:complexType>
                  <xsd:attribute name="type" default="element">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:enumeration value="element"/>
                           <!--
                              Map the message part to an XML element.
                           -->
                           <xsd:enumeration value="attribute"/>
                           <!--
                              Map the value message part to an XML element's attribute.
                              @detail
                              Only valid for value message parts.
                           -->
                           <xsd:enumeration value="value"/>
                           <!--
                              Map the value message part to an XML element's value.
                              @detail
                              Only valid for value message parts.
                           -->
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     Indicates if the message part is mapped to an XML element, attribute or value.
                  -->
                  <xsd:attribute name="subtype">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:enumeration value="dateTime"/>
                           <xsd:enumeration value="date"/>
                           <xsd:enumeration value="time"/>
                           <xsd:enumeration value="base64"/>
                           <xsd:enumeration value="hex"/>
                           <xsd:enumeration value="xsi"/>
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     Value subtype.
                  -->
                  <xsd:attribute name="format" type="xsd:string"/>
                  <!--
                     Format string to be used when formatting the value.
                     @detail
                     This property only applies to value message parts and is not to be confused with
                     the format property of the root message part.  It is used to format primitive
                     values to a specific external representation.

                     For timestamp formats see the SimpleDateFormat Java class.

                     For decimal, double, float, integer, and long formats see the DecimalFormat Java class.

                     For boolean formats we use our own formatter that supports the following values.  "Yes,True,#t;No,False,#f"
                     @note
                     <pre>
                     * the timezone from the current invocation context is used.
                     * Decimal formatting symbols from the current locale are used
                       (e.g. period or space for thousands separator, etc.)
                     * The format pattern is presumed to be a string id and is looked up in
                       the strings for the current invocation context. If not found, a second lookup
                       is attempted, prefixing the format pattern with "ids.format.". If that
                       also fails, then the format pattern is assumed to contain a format pattern
                       that can be passed directly to the format instance.
                     </pre>
                     @example
                     "h:mm a" => "12:08 PM"
                     "EEE, d MMM yyyy HH:mm:ss Z" => "Wed, 4 Jul 2001 12:08:56 -0700"
                     "#,##0.0#;(#,##0.0#)" => "1,000.0"
                  -->
                  <xsd:attribute name="node" type="xsd:string"/>
                  <!--
                     XML node name.
                     @detail
                     Name of the XML element or attribute.  This is only valid for "element" or
                     "attribute" type nodes - it is not valid for nodes of type "value".

                     A special setting in the node name property is used to provide soap
                     header support as described in the envelope property.
                  -->
                  <xsd:attribute name="namespace" type="xsd:string"/>
                  <!--
                     XML namespace alias (prefix) for this node. (Reserved prefixes: xsd, xsi, soap, soap12, wsdl, soapbind)
                     @detail
                     The namespace alias is prefixed to the element or attribute's name.  It is used
                     to disambiguate and avoid potential clashes between schema vocabularies.  The namespace
                     is optional and will not be applied to primitive message parts with a type of "value".

                     e.g. xsd:element vs chem:element

                     If a namespace prefix is used anywhere in a message, at least one of the nodes
                     with the namespace prefix must also specify the "uri" property.  This forms an
                     association between the namespace prefix and URI.  The uri property
                     may be specified on multiple nodes that have the same namespace prefix, but
                     needn't be.  If the uri for a given namespace is specified more than once, it
                     must have the same value.

                     Note: The namespace property MUST be specified on the message's root part for it 
                     be exported to a WSDL.  Without it the message definition will be skipped.  This
                     follows the WSDL specification.

                     A URI does not need to be specified for the reserved prefixes, as they are well-known.
                     
                     The reserved prefixes map to the following well-known URIs:
                     <pre>
                        xsd:      http://www.w3.org/2001/XMLSchema
                        xsi:      http://www.w3.org/2001/XMLSchema-instance
                        soap:     http://schemas.xmlsoap.org/soap/envelope/
                        soap12:   http://www.w3.org/2003/05/soap-envelope
                        wsdl:     http://schemas.xmlsoap.org/wsdl/
                        soapbind: http://schemas.xmlsoap.org/wsdl/soap/
                     </pre>
                     
                     A special setting in the namespace property is used to provide soap header
                     support as described in the envelope property.
                  -->
                  <xsd:attribute name="uri" type="xsd:string"/>
                  <!--
                     XML namespace URI. This is the namespace URI to associate with the prefix in the "namespace" property.
                     @detail
                     The uri property specifies the uri for a given namespace prefix.  This property
                     is only valid if the namespace property is specified and does not apply to
                     primitive message parts with a type of "value" (in this case, the prefix
                     will not be applied to the value, but the namespace attribute will be added
                     to the root element).

                     If a namespace prefix is used anywhere in a message, at least one of the nodes
                     with the namespace prefix must also specify the uri property.  The uri property
                     may be specified on multiple nodes that have the same namespace prefix, but
                     needn't be.  If the uri for a given namespace is specified more than once, it
                     must have the same value.
                  -->
                  <xsd:attribute name="schema" type="xsd:string"/>
                  <!--
                     The external URL at which the namespace schema document may be downloaded.
                     @detail
                     Used by formatter to produce the "xsi:schemaLocation" attribute on the root node.
                  -->
                  <xsd:attribute name="resource" type="xsd:string"/>
                  <!--
                     Space-delimited XML schema definition file locations and external URLs: {(externalURL resource) | resource}*
                     Imported schemas referenced by external URLs can be mapped to local files through the
                     parentheses notation.
                  -->
                  <xsd:attribute name="envelope">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:enumeration value="soap"/>
                           <!--
                           SOAP 1.1 envelope
                           -->
                           <xsd:enumeration value="soap12"/>
                           <!--
                           SOAP 1.2 envelope
                           -->
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     Optional soap envelope wrapper. Type may be soap (v1.1) or soap12 (v1.2).
                     @detail
                     If the envelope property is specified, the XML representation of the message
                     will be wrapped in a SOAP envelope.

                     To implement optional SOAP headers:
                     <pre>
                     1. Ensure your message has a soap envelope
                     2. Create a composite message part under the message root.  You can call it anything,
                        but something like "header" is fine
                     3. Set the mapping's type to "element"
                     4. Set the mapping's node property (node name) to "Header"
                     5. Set the mapping's namespace property to "soap" or "soap12" to match the root envelope
                     6. Put the message headers as child value parts of this element
                     </pre>

                     To get WSDL output that works across many WSDL parsing tools, adhere to the following conventions:
                     <pre>
                     1. The message's root part must map to an XML tag name that is the same as
                        the WSDL operation name.
                     2. The response message, if any, must have a different root XML tag name than
                        the request message. By defacto standard, it should be the concatenation of
                        the operation name and "Response".
                     3. The root message part should use "sequential" aggregation.
                     </pre>
                  -->
                  <xsd:attribute name="action" type="xsd:string"/>
                  <!--
                     SOAP action.
                  -->
                  <xsd:attribute name="operation" type="xsd:string"/>
                  <!--
                     WSDL operation name.
                  -->
                  <xsd:attribute name="nillable" type="xsd:boolean" default="false"/>
                  <!--
                     Set to true to use XML Schema Instance nil value semantics for this element.
                  -->
                  <xsd:attribute name="interface" type="xsd:string"/>
                  <!--
                     The interface of messages to use for parsing/formatting a primitive any-type part.
                     @detail
                     When parsing element of type "any", parse the XML content using a message from the interface
                     request and response tables. If unspecified, raw XML contents are put in a string.
                     When formatting, the class name on the transfer object is verified against the messages in
                     the interface request table followed by the response table.
                     Valid only when mapping type is "element" or "value". Message part type must be "any".
                  -->
                  <xsd:attribute name="xsdtype" type="xsd:string"/>
                  <!--
                     The XSD schema type name of this message.
                     @detail
                     Valid only for mapping on root message part.
                  -->
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="ZipMapping">
               <!--
                  Maps message parts to files in a Zip file archive.
                  @context Message
               -->
               <xsd:complexType>
                  <xsd:attribute name="comment" type="xsd:string"/>
                  <!--
                     The comment for the entire Zip file. Set only on the root message node.
                  -->
                  <xsd:attribute name="compression">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:int">
                           <xsd:minInclusive value="0"/>
                           <!--
                           0 is minimum compression - fastest.
                           -->
                           <xsd:maxInclusive value="9"/>
                           <!--
                           9 is maximum compression - slowest.
                           -->
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     The compression level for the entire Zip file. Set only on the root message node.
                  -->
                  <xsd:attribute name="value">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:enumeration value="comment"/>
                           <!--
                           The comment for the entry; null if none. string.
                           -->
                           <xsd:enumeration value="contents"/>
                           <!--
                           The uncompressed contents of the file. binary.
                           -->
                           <xsd:enumeration value="directory"/>
                           <!--
                           If set, indicates that this file is a directory.  boolean.
                           @detail
                           Not supported in the Formatter.
                           -->
                           <xsd:enumeration value="extra"/>
                           <!--
                           Optional extra data for the file. binary.
                           -->
                           <xsd:enumeration value="name"/>
                           <!--
                           The name of the file. string.
                           -->
                           <xsd:enumeration value="size"/>
                           <!--
                           The size of the file. long.
                           -->
                           <xsd:enumeration value="time"/>
                           <!--
                           The file's modification time. timestamp.
                           -->
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     The zipped file's attribute. Corresponds to attributes on java.util.zip.ZipEntry.
                  -->
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="VCardMapping">
            <!--
               Maps message parts to elements in a vCard file.
            -->
               <xsd:complexType>
                  <xsd:attribute name="name" type="xsd:string"/>
                  <!--
                     The name to use for this part in the vCard message. Defaults to the message part name.
                  -->
                  <xsd:attribute name="type" default="value">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:enumeration value="value"/>
                           <xsd:enumeration value="parameter"/>
                           <xsd:enumeration value="group"/>
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     The type of vCard element to which the message part is mapped.
                     @detail
                     value - Map to the value part of the vCard field.
                     parameter - Map to the value of a parameter on the vCard field. Name is used as the parameter name.
                     group - Logical grouping of child parts. If name not empty, it is prefixed to every field name in the group.
                     -->
                  <xsd:attribute name="default" type="xsd:string"/>
                  <!--
                     The default string to be used for a primitive message part when there is no corresponding value in the message to format. Is not escaped.
                  -->
                  <xsd:attribute name="wrapping" default="whitespace">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:enumeration value="whitespace"/>
                           <xsd:enumeration value="anywhere"/>
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     The line wrapping mode. "whitespace" to wrap lines only on whitespace; "anywhere" to wrap lines anywhere.
                  -->
                  <xsd:attribute name="quoting">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:enumeration value="none"/>
                           <xsd:enumeration value="base64"/>
                           <xsd:enumeration value="qp"/>
                           <xsd:enumeration value="vcard"/>
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     The quoting mode for non-printable data and delimiters. One of none, base64, qp (MIME quoted-printable), or vcard (backslash-escaped).
                     -->
                  <xsd:attribute name="encoding" type="xsd:string" default="US-ASCII"/>
                  <!--
                     The Java charset to use for encoding/decoding character data for the field value.
                     @detail
                     These are the charsets available on every implementation of the Java platform:

                     US-ASCII:   Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set
                     ISO-8859-1: ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1
                     UTF-8:      Eight-bit UCS Transformation Format
                     UTF-16BE:   Sixteen-bit UCS Transformation Format, big-endian byte order (when decoding, ignore BOM; when encoding, do not write BOM)
                     UTF-16LE:   Sixteen-bit UCS Transformation Format, little-endian byte order (when decoding, ignore BOM; when encoding, do not write BOM)
                     UTF-16:     Sixteen-bit UCS Transformation Format, byte order identified by an optional byte-order mark. (when decoding, interpret BOM, defaulting to big-ending if no BOM; when encoding, use big-endian and write big-endian BOM)

                     Charset names are not case-sensitive.
                  -->
                  <xsd:attribute name="delimiter" type="xsd:string" default=","/>
                  <!--
                     Used for delimiting a primitive message part collection. Defaults to ",".
                  -->
                  <xsd:attribute name="subtype">
                     <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                           <xsd:enumeration value="date"/>
                           <xsd:enumeration value="dateTime"/>
                        </xsd:restriction>
                     </xsd:simpleType>
                  </xsd:attribute>
                  <!--
                     Value subtype.
                  -->
               </xsd:complexType>
            </xsd:element>
            <xsd:element name="Mapping">
            <!--
               @context Message
            -->
               <xsd:complexType>
                  <xsd:sequence>
                     <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                  </xsd:sequence>
                  <xsd:anyAttribute processContents="lax"/>
               </xsd:complexType>
            </xsd:element>
         </xsd:choice>
      </xsd:sequence>
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Message description.
      -->
   </xsd:complexType>

   <xsd:complexType name="RootMessage">
   <!--
      Documented in baseMetadata in the Message element.
   -->
      <xsd:complexContent>
         <xsd:extension base="Message">
            <xsd:attribute name="format" type="xsd:string"/>
            <!--
                Specifies how a message is marshalled between external and internal representation.
                @detail
                For each Message we may specify a Format which defines how a message is marshalled
                between external and internal representation. The way that parts are
                mapped to external representation depends on the format. Supported formats include:
                <pre>
                * CSV - comma separated value
                * Fixed - fixed-length fields ("flat file") format
                * HL7 - health level 7 format
                * Object - the message is mapped to an internal class.
                * vCard - standard for electronic business cards.
                * XML - XML messages and optional soap wrappers.
                * Zip - represents a zip file archive.
                </pre>
            -->
            <xsd:attribute name="response" type="xsd:string"/>
            <!--
               The Response attribute allows you to pair-up a request/response set of message formats. (optional)
            -->
            <xsd:attribute name="base" type="xsd:string"/>
            <!--
               The name of the base message, if any.  Used to support message inheritance.
            -->
            <xsd:attribute name="derivation" default="virtual">
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:enumeration value="virtual"/>
                     <!--
                        Allow derived messages.
                     -->
                     <xsd:enumeration value="final"/>
                     <!--
                        Disallow derived messages.
                     -->
                     <xsd:enumeration value="abstract"/>
                     <!--
                        Require derived messages.
                     -->
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
            <!--
               Substitute with derived message during parse/format; virtual: allow; abstract: require; final: disallow.
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="Transformation">
   <!--
      A mapping to transform a source message to a destination message.
      @detail
      Both messages must be in internal format.
   -->
      <xsd:sequence>
         <xsd:element name="Initializer" type="Script" minOccurs="0" maxOccurs="1"/>
         <!--
            The Initializer is script that is run prior to the Transformation mapping.
            @detail
            The Initializer is script that is run prior to the Transformation mapping.
            It has access to all Transformation arguments, as well as "source" and "destination".
            It usually defines functions and constants used in mappings or manipulates the source record.

            If unspecified, the initializer from the base transformation will be used, if any. If "()",
            then no initializer script will be run, even if the base transformation has an initializer.
            To call the base transformation initializer, use "(call-next)".
         -->
         <xsd:element name="Mappings" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Mapping" minOccurs="0" maxOccurs="unbounded">
                  <!--
                     @context Transformation
                  -->
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:element name="Sources" minOccurs="0" maxOccurs="1">
                              <xsd:complexType>
                                 <xsd:sequence>
                                    <xsd:element name="Source" minOccurs="0" maxOccurs="unbounded">
                                       <xsd:complexType>
                                          <xsd:attribute name="name" type="identifier"/>
                                          <!--
                                             Optional source name, used as a script argument name.
                                          -->
                                          <xsd:attribute name="source" type="xsd:string"/>
                                          <!--
                                             Source message part path: part1 part2$ ... partN. Use the "$" suffix to cancel a loop.

                                             @detail
                                             The last part name may be ":oid", ":class", or ":event" to reference the corresponding
                                             special attribute.
                                          -->
                                          <xsd:attribute name="mapping" type="xsd:string"/>
                                          <!--
                                             Mapping, which result to use as the value of this source.
                                          -->
                                          <xsd:attribute name="null" type="xsd:boolean" default="false"/>
                                          <!--
                                             True to map null values, false to ignore them.
                                          -->
                                          <xsd:attribute name="default" type="xsd:string"/>
                                          <!--
                                             Default source value. "this" represents the parent and can be null. The null flag does not apply to this value.
                                          -->
                                          <xsd:attribute name="description" type="xsd:string"/>
                                          <!--
                                             Source description.
                                          -->
                                       </xsd:complexType>
                                    </xsd:element>
                                 </xsd:sequence>
                              </xsd:complexType>
                           </xsd:element>
                           <xsd:choice minOccurs="0" maxOccurs="1">
                              <xsd:element name="Script" type="Script"/>
                              <!--
                                 Script sets the mapping result from the return value of the script.
                                 @context Transformation
                              -->
                              <xsd:element name="Transformation">
                              <!--
                                 Transformation sets the mapping result by executing a transformation
                                 on the input message.
                                 @context Transformation
                              -->
                                 <xsd:complexType>
                                    <xsd:attribute name="ref" type="xsd:string" use="required"/>
                                    <!--
                                       Expression evaluating to the transformation name.
                                    -->
                                    <xsd:attribute name="args" type="xsd:string" default=""/>
                                    <!--
                                       Space-separated list of expressions evaluating to transformation arguments.
                                    -->
                                    <xsd:attribute name="source" type="xsd:string"/>
                                    <!--
                                       Expression evaluating to the input to use in the transformation; unspecified to use the first Source.
                                    -->
                                 </xsd:complexType>
                              </xsd:element>
                           </xsd:choice>
                        </xsd:sequence>
                        <xsd:attribute name="name" type="xsd:string"/>
                        <!--
                           Optional mapping name.
                        -->
                        <xsd:attribute name="destination" type="xsd:string"/>
                        <!--
                           Destination message part path: part1 part2$ ... partN. Use the "$" suffix to cancel a loop.

                           @detail
                           The last part name may be ":oid", ":class", or ":event" to reference the corresponding
                           special attribute.
                        -->
                        <xsd:attribute name="condition" type="xsd:string"/>
                        <!--
                           Boolean expression for filtering the output. It can refer to the sources as local variables.
                        -->
                        <xsd:attribute name="description" type="xsd:string"/>
                        <!--
                           Mapping description.
                        -->
                        <xsd:attribute name="layout" type="xsd:string"/>
                        <!--
                           GUI layout data.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Finalizer" type="Script" minOccurs="0" maxOccurs="1"/>
         <!--
            The Finalizer is script that is run after the Transformation mapping is complete.
            @detail
            The Finalizer is script that is run after the Transformation mapping is complete.
            It has access to all Transformation arguments, as well as "source" and "destination".
            It is usually used to manipulate the destination record.

            If unspecified, the finalizer from the base transformation will be used (if any). If "()",
            then no finalizer script will be run, even if the base transformation has a finalizer
            To call the base transformation finalizer, use "(call-next)".
         -->
      </xsd:sequence>
      <xsd:attribute name="source" type="xsd:string" use="required"/>
      <!--
         Source message or class name.

         @detail
         If there is both a message and a class with this name, then the message is used. To explicitly request a class,
         prefix the name with "class:".
      -->
      <xsd:attribute name="destination" type="xsd:string" use="required"/>
      <!--
         Destination message or class name.

         @detail
         If there is both a message and a class with this name, then the message is used. To explicitly request a class,
         prefix the name with "class:".
      -->
      <xsd:attribute name="args" type="identifierList"/>
      <!--
         Transformation arguments: arg1 arg2 ... argN.
      -->
      <xsd:attribute name="base" type="xsd:string"/>
      <!--
         The name of the base transformation, if any.
      -->
      <xsd:attribute name="derivation" default="virtual">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:enumeration value="virtual"/>
               <xsd:enumeration value="final"/>
               <xsd:enumeration value="abstract"/>
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <!--
         Substitute with derived transformation at run-time. (virtual: allow; abstract: require; final: disallow)
      -->
      <xsd:attribute name="primary" type="xsd:boolean" default="true"/>
      <!--
         True if this transformation is the primary transformation in the hierarchy for a given source message.
         @detail
         A hierarchy of transformations can contain multiple transformations with the same source
         message. If this is the case, when selecting a transformation to use to transform a
         given source message, the primary flag serves to disambiguate which transformation
         should be used.
      -->
      <xsd:attribute name="category" type="xsd:string"/>
      <!--
         The category of the transformation.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Transformation description.
      -->
   </xsd:complexType>

   <xsd:complexType name="Semaphore">
   <!--
      @context Service
   -->
      <xsd:attribute name="queue" type="xsd:string"/>
      <!--
         Expression that evaluates to the name of the SysWorkflowQueue to which this Semaphore will block.
      -->
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         Caption to display in the user interface.  This may be a string identifier.
      -->
      <xsd:attribute name="title" type="xsd:string"/>
      <!--
         Expression specifying the assignment caption string indentifier (SysWorkflowAssignment caption).
      -->
      <xsd:attribute name="assignee" type="xsd:string"/>
      <!--
         Expression specifying a principal used to determine which users may take ownership of the assignment.
         @detail
         The assignee is a principal so it may be a user or user group.  Any user that that is set as the
         assignee or is a member of the group specified as the assignee may take ownership of the assingment.
      -->
      <xsd:attribute name="owner" type="xsd:string"/>
      <!--
         Expression specifying a user who owns the assignment. Once an assignment is owned, it appears only in the queue of its owner.
         -->
      <xsd:attribute name="factory" type="xsd:string" default="SysWorkflowAssignment 'new"/>
      <!--
         The factory for SysWorkflowAssignment subclasses. Space-separated list of the form "AssignmentClass ['event [arg1 arg2 ... argN]]".
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Semaphore block description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="Goto">
   <!--
      A Goto directs the flow of an activity from the current location to a named subsequent node.  
   -->
      <xsd:attribute name="next" type="xsd:string"/>
      <!--
        The name of the next step.  The value defaults to the end of the activity.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
        A description for the connector between two activity steps. This text is displayed as an element note in the activity diagram.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
      <!--
      This attribute captures the UI layout information for rendering the model in the editor. The values change as users moves the element in the editor.
      -->
   </xsd:complexType>

   <xsd:complexType name="ScriptStep">
   <!--
      @context Activity
   -->
      <xsd:complexContent>
         <xsd:extension base="Script">
            <xsd:attribute name="name" type="xsd:string" use="required"/>
            <!--
               Step name.
            -->
            <xsd:attribute name="caption" type="xsd:string"/>
            <!--
               String identifier for caption display in the UI.
            -->
            <xsd:attribute name="description" type="xsd:string"/>
            <!--
               Script description.
            -->
            <xsd:attribute name="layout" type="xsd:string"/>
            <!--
               GUI layout data.
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="Catch">
      <xsd:attribute name="exception" type="qualJavaName"/>
      <!--
         Exception class to catch. By default, catches any exception.
      -->
      <xsd:attribute name="condition" type="xsd:string"/>
      <!--
         Catch condition. Only the first catch branch with matching exception and true condition is executed. Defaults to true.
      -->
      <xsd:attribute name="name" type="xsd:string"/>
      <!--
         Catch name.
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         String identifier for caption display in the UI.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Catch branch description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
      <!--
         GUI layout data.
      -->
   </xsd:complexType>

   <xsd:complexType name="TryCatch">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         String identifier for caption display in the UI.
      -->
      <xsd:attribute name="variable" type="identifier"/>
      <!--
         Variable, in which to store the caught exception.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Try-catch block description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
      <!--
         GUI layout data.
      -->
   </xsd:complexType>

   <xsd:complexType name="Transform">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         String identifier for caption display in the UI.
      -->
      <xsd:attribute name="transformation" type="xsd:string" use="required"/>
      <!--
         Expression evaluating to the transformation name.
      -->
      <xsd:attribute name="args" type="xsd:string" default=""/>
      <!--
         Space-separated list of expressions evaluating to transformation arguments.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Transformation description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
      <!--
         GUI layout data.
      -->
   </xsd:complexType>

   <xsd:complexType name="Loop">
   <!--
      @context Service
   -->
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
        Step name.
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
        Caption for the loop in the service editor.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
        Loop description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
      <!--
        GUI layout data.
      -->
   </xsd:complexType>

   <xsd:complexType name="Dispatch_Case">
   <!--
      A Service Dispatch Case with either a condition or message to control the Service flow.
      @detail
      Dispatch Cases are evaluated and the flow of control follows the first Case that is true.
      They can be used for message type or content based routing.
      Each case has either its 'condition' or 'message' property set.  If both are set, the
      message property takes precedence.  The 'message' cases are checked in metadata ordinal
      order then 'condition' cases are checked in the same metadata order.  'conditions' are
      boolean scheme expressions while 'messages' are Message types compared against message type of the
      Service's underlying message (or 'this').  The metadata ordinal order is visually
      indicated in the NexJ Studio Service Editor.
   -->
      <xsd:annotation>
         <xsd:appinfo>
            <Collection key="message condition"/>
         </xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="message" type="xsd:string"/>
      <!--
         Message type symbol compared against 'this'.  Takes precedence over the 'condition' property.
      -->
      <xsd:attribute name="condition" type="xsd:string"/>
      <!--
         Boolean scheme expression.  Evaluated to control Service flow.
      -->
      <xsd:attribute name="name" type="xsd:string"/>
      <!--
         Case name.
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         String identifier for caption display in the UI.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Case description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
      <!--
         GUI layout data.
      -->
   </xsd:complexType>

   <xsd:complexType name="Dispatch">
   <!--
      A Service Dispatch branches control within the Service based on conditional logic.
      @detail
      A dispatch is made up of a number of Cases.  Each Case is evaluated and the flow of
      control follows the first one whose condition is true.  Cases are evaluated based on
      scheme expressions or message types.
   -->
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Dispatch description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
      <!--
         GUI layout data.
      -->
   </xsd:complexType>

   <xsd:complexType name="Persist">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         String identifier for caption display in the UI.
      -->
      <xsd:attribute name="respond" type="xsd:boolean" default="false"/>
      <!--
         True to return the object response message.
      -->
      <xsd:attribute name="onError" type="onErrorType" default="fail"/>
      <!--
         If an error occurs, "fail" throws the first encountered exception, "collect" throws a compound exception with all the errors and "commit" persists the correct instances and throws a compound exception with all the errors.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Step description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
      <!--
         GUI layout data.
      -->
   </xsd:complexType>

   <xsd:complexType name="Sync">
   <!--
      An (optional) custom synchronization script.

      @detail
      This script, for example, could specify custom conflict detection and resolution is required.
      In addition to "this" (current transfer object), the script can use variables "instance"
      (the current state of the instance that is going to be updated), "old"
      (transfer object containing last image of the instance sent from this link) and "conflicts"
      (a list of property symbols whose values have been updated by both NexJ and external systems).
      The script can modify the instance, and should return a symbol indicating the conflict resolution strategy,
      or a list of symbols indicating the resolution strategy for each conflict in the conflicts list.
      The following strategies are supported: "won" (changes made on NexJ system should take preference), "lost"
      (changes made by the external system win), "done" (the script has resolved the conflict by updating the instance,
      but all non-conflicting changes have to be applied by the framework) and "rejected" (the script has rejected the update).
   -->
      <xsd:complexContent>
         <xsd:extension base="Script">
             <xsd:attribute name="name" type="xsd:string" use="required"/>
             <!--
                Step name.
             -->
             <xsd:attribute name="caption" type="xsd:string"/>
             <!--
                String identifier for caption display in the UI.
             -->
             <xsd:attribute name="onError" type="onErrorType" default="fail"/>
             <!--
                If an error occurs, "fail" throws the first encountered exception, "collect" throws a compound exception with all the errors and "commit" persists the correct instances and throws a compoundt exception with all the errors.
             -->
             <xsd:attribute name="link" type="xsd:string" use="required"/>
             <!--
                Expression evaluating to the synchronization link instance.
             -->
             <xsd:attribute name="description" type="xsd:string"/>
             <!--
                Script description.
             -->
             <xsd:attribute name="layout" type="xsd:string"/>
             <!--
                GUI layout data.
             -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="Send">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         String identifier for caption display in the UI.
      -->
      <xsd:attribute name="output" type="xsd:string"/>
      <!--
         Expression evaluating to the output channel name. If not specified, taken from the message "channel" part.
      -->
      <xsd:attribute name="interface" type="xsd:string"/>
      <!--
         Service interface. If specified, the message is transformed into a channel payload message.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Step description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
      <!--
         GUI layout data.
      -->
   </xsd:complexType>

   <xsd:complexType name="SendReceive">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         String identifier for caption display in the UI.
      -->
      <xsd:attribute name="output" type="xsd:string"/>
      <!--
         Expression evaluating to the output channel name. If not specified, taken from the message "channel" part.
      -->
      <xsd:attribute name="interface" type="xsd:string"/>
      <!--
         Service interface. If specified, the message is transformed into and from a channel payload message.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Step description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
      <!--
         GUI layout data.
      -->
   </xsd:complexType>

   <xsd:complexType name="Action">
   <!--
      Code step within a Workflow.
      @context Workflow
   -->
      <xsd:complexContent>
         <xsd:extension base="Script">
            <xsd:attribute name="name" type="xsd:string" use="required"/>
            <!--
               Step name.
            -->
            <xsd:attribute name="caption" type="xsd:string"/>
            <!--
                 String indentifier for caption display in the UI.
            -->
            <xsd:attribute name="association" type="identifierList"/>
            <!--
               Association path from the primary workflow class to the class with the triggering event: attr1 ... attrN.
            -->
            <xsd:attribute name="event" type="identifier"/>
            <!--
               Event which triggers the action.
            -->
            <xsd:attribute name="args" type="nonNegativeInt"/>
            <!--
               Event argument count. Specifies the signature of the event that triggers the action. If blank, args is 0.
               @detail A class may have multiple events with the same name as long as their argument count differs. This attribute
               is used to specify the event to which this action is associated.
            -->
            <xsd:attribute name="condition" type="xsd:string"/>
            <!--
               Condition under which the action is executed when the event is invoked. Relative to the association end class.
            -->
            <xsd:attribute name="description" type="xsd:string"/>
            <!--
               Action description.
            -->
            <xsd:attribute name="layout" type="xsd:string"/>
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="Timeout">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         String indentifier for caption display in the UI.
      -->
      <xsd:attribute name="value" type="xsd:string" use="required"/>
      <!--
         Expression specifying the delay value in milliseconds.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Timeout description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="Decision_Branch">
   <!--
      Branches within a decision of a Service or Workflow.
      @context Service or Workflow
   -->
      <xsd:attribute name="condition" type="xsd:string"/>
      <!--
         Branching condition. Only the first branch with true condition is executed. Defaults to true.
      -->
      <xsd:attribute name="name" type="xsd:string"/>
      <!--
         Branch name.
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         String indentifier for caption display in the UI.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Branch description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="Decision">
   <!--
       @context Workflow
   -->
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="manual" type="xsd:boolean" default="false"/>
      <!--
         True to specify that the user has to make the choice. Only valid if preceded by a manual assignment.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Decision description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="Join">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="type" default="all">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:enumeration value="all"/>
               <!--
                  Proceed to the next step only when all concurrent activities within the Join finish.
                  Execution is single-thread, alternating between branches as necessary.
               -->
               <xsd:enumeration value="any"/>
               <!--
                  Proceed to the next step when the first activity withing the Join finishes.  All
                  others are rolled back.
                  Execution is single-thread, alternating between branches as necessary.
               -->
               <xsd:enumeration value="parallel"/>
               <!--
                  Run each concurrent activity in a separate thread and wait for all threads to complete
                  before proceeding to the next step.
                  This is the only option that will be multi-threaded.
               -->
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <!--
         Specifies whether all concurrent activites must be completed before proceeding to the next step.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Join description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="Assignment">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         String identifier for caption display in the UI.
      -->
      <xsd:attribute name="association" type="identifierList"/>
      <!--
         Association path from the primary workflow class to the class with the triggering event: attr1 ... attrN.
      -->
      <xsd:attribute name="event" type="identifier"/>
      <!--
         Event which completes the assignment. If not specified, the workflow assignee is required to complete the workflow.
      -->
      <xsd:attribute name="args" type="nonNegativeInt"/>
      <!--
         Event argument count.
      -->
      <xsd:attribute name="condition" type="xsd:string"/>
      <!--
         Assignment completion condition. Used only if event is specified.
      -->
      <xsd:attribute name="priority" type="xsd:string"/>
      <!--
         Expression specifying the assignment priority as a double number from 0 to 10, 0 being the highest. Defaults to 4.
      -->
      <xsd:attribute name="assignee" type="xsd:string"/>
      <!--
         Expression specifying a principal who can take ownership of the assignment.
      -->
      <xsd:attribute name="owner" type="xsd:string"/>
      <!--
         Expression specifying a user who owns the assignment. Once an assignment is owned, it appears only in the queue of its owner.
      -->
      <xsd:attribute name="title" type="xsd:string"/>
      <!--
         Expression specifying the assignment caption string indentifier (SysWorkflowAssignment caption).
      -->
      <xsd:attribute name="queue" type="xsd:string"/>
      <!--
         Workflow queue.
      -->
      <xsd:attribute name="target" type="identifierList"/>
      <!--
         Association path relative to the workflow primary class: attr1 ... attrN. Used to find a UI assignment form if unspecified in the form property.
      -->
      <xsd:attribute name="form" type="xsd:string"/>
      <!--
         Assignment form name: screenRef formRef.
      -->
      <xsd:attribute name="uimode" type="uimode" default="modeless"/>
      <!--
         Assignment form UI mode.
      -->
      <xsd:attribute name="factory" type="xsd:string" default="SysWorkflowAssignment 'new"/>
      <!--
         The factory for SysWorkflowAssignment subclasses. Space-separated list of the form "AssignmentClass ['event [arg1 arg2 ... argN]]".
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Assignment description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="Queue_TimerEvent">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="value" type="xsd:string" use="required"/>
      <!--
         Expression specifying the delay value in milliseconds.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Timer event description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="Queue_ClassEvent">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="association" type="identifierList"/>
      <!--
         Association path from the primary workflow class to the class with the triggering event: attr1 ... attrN.
      -->
      <xsd:attribute name="event" type="identifier" use="required"/>
      <!--
         Class event which exits from the queue.
      -->
      <xsd:attribute name="args" type="nonNegativeInt"/>
      <!--
         Class event argument count.
      -->
      <xsd:attribute name="condition" type="xsd:string"/>
      <!--
         Condition under which the queue is exited from when the event is invoked. Relative to the association end class.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Class event description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="Queue_ProcessEvent">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Process event description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="Queue_ManualEvent">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="condition" type="xsd:string"/>
      <!--
         Condition under which this event exits the queue.
      -->
      <xsd:attribute name="target" type="identifierList"/>
      <!--
         Association path relative to the workflow primary class: attr1 ... attrN. Used to find a UI form if unspecified in the form property.
      -->
      <xsd:attribute name="form" type="xsd:string"/>
      <!--
         UI form name: screenRef formRef.
      -->
      <xsd:attribute name="uimode" type="uimode" default="modeless"/>
      <!--
         UI form mode.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Manual event description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="Queue">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <!--
         Step name.
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         String indentifier for caption display in the UI.
      -->
      <xsd:attribute name="priority" type="xsd:string"/>
      <!--
         Expression specifying the assignment priority as a double number from 0 to 10, 0 being the highest. Defaults to 4.
      -->
      <xsd:attribute name="assignee" type="xsd:string"/>
      <!--
         Expression specifying a principal, who can take ownership of the assignment.
      -->
      <xsd:attribute name="owner" type="xsd:string"/>
      <!--
         Expression specifying a user, who owns the assignment. Once an assignment is owned, it appears only in the queue of its owner.
      -->
      <xsd:attribute name="title" type="xsd:string"/>
      <!--
         Expression specifying the assignment caption string indentifier (SysWorkflowAssignment caption).
      -->
      <xsd:attribute name="queue" type="xsd:string"/>
      <!--
         Expression that evaluates to the name of the SysWorkflowQueue to use.
      -->
      <xsd:attribute name="factory" type="xsd:string" default="SysWorkflowAssignment 'new"/>
      <!--
         The factory for SysWorkflowAssignment subclasses. Space-separated list of the form "AssignmentClass ['event [arg1 arg2 ... argN]]".
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Queue description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="UIAction">
   <!--
      @context Presentation
   -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         String indentifier for caption display in the UI.
      -->
      <xsd:attribute name="target" type="identifierList"/>
      <!--
         Association path relative to the workflow primary class: attr1 ... attrN. Used to find a UI form if unspecified in the form property.
      -->
      <xsd:attribute name="form" type="xsd:string"/>
      <!--
         UI form name: screenRef formRef.
      -->
      <xsd:attribute name="uimode" type="uimode" default="modeless"/>
      <!--
         UI form mode.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         UI action description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="Interface">
    <!--
       Service interface.  Contains a list of valid Request and/or Response messages for a Service.
       @detail
       The service interface limits which message types can be received or sent to and from a Service.  Messages sent or received through an interface will automatically have their external formatting applied.  Otherwise, they will be sent or received 'raw'.
    -->
      <xsd:sequence>
         <xsd:element name="Requests" minOccurs="0" maxOccurs="1">
         <!--
            Collection of request messages that the service can receive.
         -->
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Request" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:attribute name="message" type="xsd:string" use="required"/>
                        <!--
                           Request message name. If the message specifies a response, it is included automatically in the responses.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Responses" minOccurs="0" maxOccurs="1">
         <!--
            Collection of message types that the service can send.
         -->
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Response" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:attribute name="message" type="xsd:string" use="required"/>
                        <!--
                           Extra response message name. If a request message specifies a response, it is included automatically in the responses.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="format" type="xsd:string"/>
      <!--
         Interface message format.  Used to validate that all Request and Response messages are of the correct format. (optional)
         @detail
         You cannot mix message format types in an interface.  e.g. You cannot have a CSV message and an XML message in the same Request list.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Interface description.
      -->
   </xsd:complexType>

   <xsd:group name="Sequence">
      <xsd:choice>
         <xsd:element name="Script" type="ScriptStep"/>
         <xsd:element name="Goto" type="Goto"/>
         <xsd:element name="Transform" type="Transform"/>
         <xsd:element name="Dispatch">
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Dispatch">
                     <xsd:sequence>
                        <xsd:element name="Case" minOccurs="1" maxOccurs="unbounded">
                           <xsd:complexType>
                              <xsd:complexContent>
                                 <xsd:extension base="Dispatch_Case">
                                    <xsd:group ref="Sequence" minOccurs="0" maxOccurs="unbounded"/>
                                 </xsd:extension>
                              </xsd:complexContent>
                           </xsd:complexType>
                        </xsd:element>
                     </xsd:sequence>
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Loop">
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Loop">
                     <xsd:group ref="Sequence" minOccurs="0" maxOccurs="unbounded"/>
                     <xsd:attribute name="collection" type="xsd:string" default="this"/>
                     <!--
                        Expression returning a list, collection, or iterator. Defaults to 'this'.
                        @example
                        '(1 1 2 3 5)
                     -->
                     <xsd:attribute name="variable" type="identifier" default="this"/>
                     <!--
                        The name of the service variable into which the current item will be placed. Defaults to 'this'.
                     -->
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Semaphore">
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Semaphore">
                     <xsd:group ref="Sequence" minOccurs="0" maxOccurs="unbounded"/>
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="TryCatch">
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="TryCatch">
                     <xsd:sequence>
                        <xsd:element name="Try" minOccurs="0" maxOccurs="1">
                           <xsd:complexType>
                              <xsd:group ref="Sequence" minOccurs="0" maxOccurs="unbounded"/>
                           </xsd:complexType>
                        </xsd:element>
                        <xsd:element name="Catch" minOccurs="0" maxOccurs="unbounded">
                           <xsd:complexType>
                              <xsd:complexContent>
                                 <xsd:extension base="Catch">
                                    <xsd:group ref="Sequence" minOccurs="0" maxOccurs="unbounded"/>
                                 </xsd:extension>
                              </xsd:complexContent>
                           </xsd:complexType>
                        </xsd:element>
                        <xsd:element name="Finally" minOccurs="0" maxOccurs="1" type="Script"/>
                        <!--
                           A script that is run when the flow leaves the try block, either normally or through an exception.
                           @context Service
                        -->
                     </xsd:sequence>
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Persist" type="Persist"/>
         <xsd:element name="Sync" type="Sync"/>
         <xsd:element name="Send" type="Send"/>
         <xsd:element name="SendReceive" type="SendReceive"/>
         <xsd:element name="Join">
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Join">
                     <xsd:sequence>
                        <xsd:element name="Sequence" minOccurs="1" maxOccurs="unbounded">
                        <!--
                           Step within a Join of a Service.  e.g. Script, Transform, Try, Branch...
                        -->
                           <xsd:complexType>
                              <xsd:group ref="Sequence" minOccurs="0" maxOccurs="unbounded"/>
                              <xsd:attribute name="args" type="xsd:string"/>
                              <!--
                                 A collection of values to be passed individually to each of the threads.
                              -->
                              <xsd:attribute name="variable" type="identifier"/>
                              <!--
                                 The name of the Service variable that will be used for the thread argument of this Fork/Join block.
                              -->
                           </xsd:complexType>
                        </xsd:element>
                     </xsd:sequence>
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:any processContents="skip"/>
      </xsd:choice>
   </xsd:group>

   <xsd:complexType name="Service">
      <xsd:group ref="Sequence" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:attribute name="interface" type="xsd:string"/>
      <!--
         Service interface. If not specified, the service can accept any message and sends/receives them 'raw'.
      -->
      <xsd:attribute name="args" type="identifierList"/>
      <!--
         Service arguments: arg1 arg2 ... argN.  A special argument is :output which keeps track of the output channel.
         @detail
         These are arguments that the service expects.  They can be passed in by SysService'invoke... or by
         setting the properties on a Service Binding.
      -->
      <xsd:attribute name="variables" type="identifierList"/>
      <!--
         Service variables: var1 var2 ... varN.
         @details
         Variables can be used to pass information from step to step or control message flow.
      -->
      <xsd:attribute name="privilege" type="xsd:string"/>
      <!--
         Privilege required to invoke the service.
         @category Security
      -->
      <xsd:attribute name="privileged" type="xsd:boolean" default="false"/>
      <!--
         True to execute the service in privileged mode (without security restrictions).
         @category Security
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Service description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
      <!--
         GUI layout data.
      -->
   </xsd:complexType>

   <xsd:complexType name="CustomProperties">
   <!--
      @context Connection
   -->
      <xsd:sequence>
         <xsd:element name="Property" minOccurs="0" maxOccurs="unbounded">
         <!--
            @context Connection
         -->
            <xsd:complexType>
               <xsd:attribute name="name" type="xsd:string" use="required"/>
               <!--
                  Custom property name.
               -->
               <xsd:attribute name="value" type="xsd:string"/>
               <!--
                  Custom property value.
               -->
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>

   <xsd:complexType name="Configuration">
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Description of the Server.
      -->
      <xsd:attribute name="test" type="xsd:boolean" default="false"/>
      <!--
         Flag set to specify if the server may be used for testing.
      -->
      <xsd:attribute name="type" type="serverType" use="required"/>
      <!--
         J2EE container type.
         @detail
         One of WebSphere, JBoss or Generic (NJAS).
      -->
      <xsd:attribute name="location" type="xsd:string"/>
      <!--
         Container-specific deployment location.
         @category Deployment
      -->
      <xsd:attribute name="user" type="xsd:string"/>
      <!--
         Deployment administrator user name.
         @category Deployment
      -->
      <xsd:attribute name="password" type="password"/>
      <!--
         Deployment administrator password.
         @category Deployment
      -->
      <xsd:attribute name="authProtocol" type="authProtocol" default="basic"/>
      <!--
         Authentication protocol.
         @category Security
      -->
      <xsd:attribute name="authService" type="xsd:string" default="HTTP/nexj"/>
      <!--
         Authentication service Kerberos principal, usually HTTP/host.domain.ext.
         @category Security
      -->
      <xsd:attribute name="authDomain" type="xsd:string"/>
      <!--
         Authentication domain or Kerberos realm, usually DOMAIN.EXT in capital letters.
         @category Security
      -->
      <xsd:attribute name="sessionTimeout" type="nonNegativeInt" default="20"/>
      <!--
         Logon session timeout in minutes (0 is unlimited). With persistent sessions, it is the period of inactivity before the session is persisted.
         @category Security
      -->
      <xsd:attribute name="secureTransport" type="xsd:boolean" default="true"/>
      <!--
         Use SSL for encrypted communication and server authentication.
         @category Security
      -->
      <xsd:attribute name="httpGZip" type="xsd:boolean" default="false"/>
      <!--
         Compress the HTTP traffic to minimize the network bandwidth at substantial performance cost.
         @category Communication
      -->
      <xsd:attribute name="httpURL" type="xsd:string"/>
      <!--
         HTTP server URL, if non-default. If URL contains no HTTP context path, then context defaults to "/nexj".
         @category Communication
         @example
         http://server.domain:port       (Yields Contact App URL: http://server.domain:port/nexj/Contact.jnlp)
         http://server.domain:port/      (Yields Contact App URL: http://server.domain:port/Contact.jnlp)
         http://server.domain:port/crm/  (Yields Contact App URL: http://server.domain:port/crm/Contact.jnlp)
         /                               (Yields Contact App URL: http://default/Contact.jnlp)
         /crm                            (Yields Contact App URL: http://default/crm/Contact.jnlp)
      -->
      <xsd:attribute name="httpAnonymousURL" type="xsd:string"/>
      <!--
         HTTP server anonymous content URL. Defaults to "/nexj/anon".
         @category Communication
         @detail
         Requests made under this context root are logged in as the user specified in "anonUser".
         Flat web client is exposed if "anonWeb" is true.
         HTTP RPC protocols are exposed if "anonRPC" is true.
         HTTP integration channels are exposed if their "authentication" is "none".
      -->
      <xsd:attribute name="httpMaxSize" type="nonNegativeInt" default="10485760"/>
      <!--
         Maximum HTTP request size in bytes (0 is unlimited).
         @category Communication
      -->
      <xsd:attribute name="httpLockTimeout" type="nonNegativeInt" default="10"/>
      <!--
         HTTP session lock timeout in seconds (0 is unlimited).
         @category Communication
      -->
      <xsd:attribute name="keystorePassword" type="password" default="keypass"/>
      <!--
         The password for the SSL keystore that holds server certificates.
         @category Security
      -->
      <xsd:attribute name="trust" type="xsd:string"/>
      <!--
         The X.509 certificate, or signer's certificate thereof, for the remote system. Unspecified to trust certificates in default trust store.
         @category Security

         @detail
         The CN from the certificate presented by the remote system is used as the user principal for which the invocation context
         will be created. This allows support of multiple external systems authenticating to an HTTP channel, mapped
         to different users based on the certificates they present.  http://en.wikipedia.org/wiki/X.509
      -->
      <xsd:attribute name="httpFormURL" type="xsd:string"/>
      <!--
         HTTP server form-based-authentication URL. Defaults to "/nexj/form".
         @category Communication
         @detail
         Pages under the form-based-authentication URL should always be accessed via HTTPS to prevent password
         snooping at login time.
      -->
      <xsd:attribute name="httpFormLoginPage" type="xsd:string" default="/login.htm"/>
      <!--
         Path from root of WAR to the login page. Must start with "/".
         @category Communication
         @detail
         The login page is displayed when an unauthenticated request is made to any secured resource
         under the form-based-authentication URL. There should be a login form on this page, allowing
         the user to authenticate.

         The login form should submit to the virtual action "j_security_check". The POST request should
         have the username passed in the text field "j_username" and the password in "j_password".
      -->
      <xsd:attribute name="httpFormErrorPage" type="xsd:string" default="/login-error.htm"/>
      <!--
         Path from root of WAR to the login error page. Must start with "/".
         @category Communication
      -->
      <xsd:attribute name="authRPC" type="xsd:boolean" default="true"/>
      <!--
         True to enable basic and SPNEGO authentication access to generic RPC protocols; false to disable.
         @category Security
         @detail
         Generic RPC protocols are HTTP/soap, HTTP/text, HTTP/web, HTTP/xml and EJB.
         They are used by all the clients except for the flat page client.
         If authProtocol is "certificate" and "trust" is not set, setting authRPC to "false" disables the generic RPC protocols altogether.
      -->
      <xsd:attribute name="rpcPrivilege" type="xsd:string"/>
      <!--
         Privilege required for access to generic RPC protocols. If not set, the access is unrestricted and a validation warning is generated.
         @category Security
         @detail
         Generic RPC protocols are HTTP/soap, HTTP/text, HTTP/web, HTTP/xml and EJB.
         Generic RPC is used by all the clients except for the flat page client.
      -->
      <xsd:attribute name="anonRPC" type="xsd:boolean" default="false"/>
      <!--
         True to enable anonymous access to HTTP/soap, HTTP/text, HTTP/web and HTTP/xml RPC protocols; false to disable.
         @category Security
         @detail
         Anonymous requests will be processed in an invocation context where the user is the user
         specified in the "anonUser" property.
         The HTTP/text RPC protocol is used by all the clients except for the flat page client.
         @see
         Server.anonUser
      -->
      <xsd:attribute name="anonUser" type="xsd:string" default="anonymous"/>
      <!--
         The user that anonymous HTTP requests will be authenticated as. Domain appended by framework when SPNEGO used.
         @category Security
         @detail
         anonRPC anonWeb HttpConnection.authentication
      -->
      <xsd:attribute name="anonWeb" type="xsd:boolean" default="false"/>
      <!--
         True to enable anonymous access to the flat page client.
         @category Security
         @detail
         Anonymous requests will be processed in an invocation context where the user is the user
         specified in the "anonUser" property.
         @see
         Server.anonUser
      -->
      <xsd:attribute name="maxMessageSenders" type="nonNegativeInt" default="16"/>
      <!--
         Maximum number of connections to the object queueing engine.
         @category Queueing
      -->
      <xsd:attribute name="maxMessageReceivers" type="nonNegativeInt" default="16"/>
      <!--
         Maximum number of threads used by object queueing engine.
         @category Queueing
      -->
      <xsd:attribute name="pushRedirectorURL" type="xsd:string"/>
      <!--
         The URL (full path) of the push redirector.
         @category Push
      -->
      <xsd:attribute name="pushServerURLs" type="xsd:string"/>
      <!--
         List of space separated push server node URLs (full path) to which the push redirector should connect.
         @category Push
      -->
      <xsd:attribute name="pushTimeout" type="nonNegativeLong"/>
      <!--
         The time in ms after which the connection from client to push redirector will timeout and cause a heartbeat to be sent to the client.
         @category Push
      -->
      <xsd:attribute name="pushUser" type="xsd:string"/>
      <!--
         The user name with which the push redirector will authenticate with the push server node(s).
         @category Push
      -->
      <xsd:attribute name="pushPassword" type="password"/>
      <!--
         The password with which the push redirector will authenticate with the push server node(s).
         @category Push
      -->
      <xsd:attribute name="pushTrust" type="xsd:string"/>
      <!--
         The push server SSL certificate that the push redirector should trust.
         @category Push
         @see Trust property
      -->
      <xsd:attribute name="pushType" type="pushType" default="streaming"/>
      <!--
         The type of Comet to use for push notifications. If the selected type isn't supported by the client web browser, polling is used.
         @category Push
      -->
      <xsd:anyAttribute processContents="lax"/>
   </xsd:complexType>

   <xsd:complexType name="SecurityDescriptor">
      <xsd:sequence>
         <xsd:element name="Privileges" minOccurs="0" maxOccurs="1">
         <!--
            @context Security Descriptor
         -->
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Privilege" minOccurs="0" maxOccurs="unbounded">
                  <!--
                     @context Security Descriptor
                  -->
                     <xsd:complexType>
                        <xsd:attribute name="name" type="xsd:string" use="required"/>
                        <!--
                           Privilege name. A primitive privilege can restrict access to a class attribute or an event.
                        -->
                        <xsd:attribute name="caption" type="xsd:string"/>
                        <!--
                           String identifier for caption display in the UI.
                        -->
                        <xsd:attribute name="description" type="xsd:string"/>
                        <!--
                           Primitive privilege description.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="PrivilegeGroups" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="PrivilegeGroup" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:element name="Privileges" minOccurs="0" maxOccurs="1">
                           <!--
                              @context Privilege Group
                           -->
                              <xsd:complexType>
                                 <xsd:sequence>
                                    <xsd:element name="Privilege" minOccurs="0" maxOccurs="unbounded">
                                    <!--
                                       @context Privilege Group
                                    -->
                                       <xsd:complexType>
                                          <xsd:attribute name="name" type="xsd:string" use="required"/>
                                          <!--
                                             Referenced privilege or privilege group name.
                                          -->
                                       </xsd:complexType>
                                    </xsd:element>
                                 </xsd:sequence>
                              </xsd:complexType>
                           </xsd:element>
                        </xsd:sequence>
                        <xsd:attribute name="name" type="xsd:string" use="required"/>
                        <!--
                           Privilege group name.
                        -->
                        <xsd:attribute name="caption" type="xsd:string"/>
                        <!--
                           String identifier for caption display in the UI.
                        -->
                        <xsd:attribute name="description" type="xsd:string"/>
                        <!--
                           Privilege group description.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>

   <xsd:complexType name="RelationalMapping">
   <!--
      Relational Persistence Mapping
      @detail
      A class persistence mapping specifies how its instances will be persisted in a given datasource.

      Persistent datasource, in which the instances of this class are stored.

      A class with a relational persistence mapping will persist to a relational database.
   -->
      <xsd:sequence>
         <xsd:element name="AttributeMappings" minOccurs="0" maxOccurs="1">
            <!--
               Collection of Relational Attribute Mappings
               @context Relational
            -->
            <xsd:annotation>
               <xsd:appinfo>
                  <Collection ordered="false"/>
               </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="AttributeMapping" minOccurs="0" maxOccurs="unbounded">
                  <!--
                     Class attribute's mapping to a relational database column
                     @context Relational
                  -->
                     <xsd:complexType>
                        <xsd:choice minOccurs="0" maxOccurs="1">
                           <xsd:element name="PersistenceMapping" type="PersistenceMapping"/>
                        </xsd:choice>
                        <xsd:attribute name="name" type="identifier" use="required"/>
                        <!--
                           Attribute name to map to a database column
                           @detail
                           If the attribute is primitive, then the column property (and optionally the table property) are
                           used to map to a database column.

                           If the attribute is non-primitive (i.e. it represents an association), the source key and
                           destination keys specify the primary key / foreign key relationship used to navigate the association.
                           If the association is two-way (i.e. has a reverse association), the persistence mapping on
                           the other class's reverse attribute will use the same indexes, but the values will be switched
                           for the source key and destination key .
                        -->
                        <xsd:attribute name="table" type="tableName"/>
                        <!--
                           The table containing the column to which the primitive attribute is mapped.  Used only for primitive attributes.
                           @detail
                           This property defaults to the class's primary table if left blank.  Only enter a name here
                           if mapping to a column in an "extension table".  An extension table shares its primary key
                           on a one-to-one basis with the primary table's key.  The framework transparently manages
                           the creation, read, update, and delete of extension table records alongside the primary table records.
                        -->
                        <xsd:attribute name="column" type="dbObjName"/>
                        <!--
                           The database column to which the primitive attribute is mapped. Used only for primitive attributes.
                           @detail
                           The database column to which the primitive attribute is mapped. Used only for primitive attributes.
                           The column must exist in the primary table, or in the "extension table" specified in the attribute
                           mapping's table property.
                        -->
                        <xsd:attribute name="sourceKey" type="indexName"/>
                        <!--
                           A key that provides the association between the source (this) and destination class. Used only for non-primitive attributes.
                           @detail
                           For relational datasources the source key is usually an index from the primary table for this class, but
                           may also be an index from an "extension table".
                           The index is a primary key or foreign key and is used to join from the source table to the destination's foreign key or
                           primary key respectively.  Defaults to the primary key.
                           @example
                           Person'homeAddress is of type Address.  The Address class has a reverse association attribute of "person" and is also
                           persisted to a RelationalDatasource.

                           The persistence mapping for Person'homeAddress is:
                           sourceKey: Person.PK, destinationKey: Address.FK_person

                           The persistence mapping for Address'person is:
                           sourceKey: Address.FK_person, destinationKey: Person.PK
                        -->
                        <xsd:attribute name="destinationKey" type="xsd:string"/>
                        <!--
                           A key from the destination class that provides a link between the associated class and this one. Used only for non-primitive attributes.
                           @detail
                           The meaning of the destination key varies by the associated class' persistence mapping.

                           For classes with a relationalDatabase persistence mapping, the destination table is usually the primary table of the attribute type's
                           class (non-primitive), but may also be an extension table of that class.
                           The key is a primary key or foreign key and is used to join from the destination table to the source table's foreign key or
                           primary key respectively.  Defaults to the primary key.
                           @example
                           Person'homeAddress is of type Address.  The Address class has a reverse association attribute of "person".

                           The persistence mapping for Person'homeAddress is:
                           sourceKey: Person.PK, destinationKey: Address.FK_person

                           The persistence mapping for Address'person is:
                           sourceKey: Address.FK_person, destinationKey: Person.PK
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Hook" type="Component" minOccurs="0" maxOccurs="1"/>
      </xsd:sequence>
      <xsd:attribute name="primaryTable" type="tableName"/>
      <!--
         Primary table where instances of the class are persisted.
         @detail
         It is used for exclusive and optimistic locking and contains the locking attribute.
         Extension tables are are joined to it by the primary key and can be specified in attribute
         mappings "table" property.
      -->
      <xsd:attribute name="keyGenerator" type="componentName"/>
      <!--
         Component for key generation, implementing the OIDGenerator interface.
         @detail
         <pre>
         Examples of key generators include:
         * "identity" - database based identity generator/sequence.
         * KeyGenerator.Counter - persistent counter.  Requires a SysCounter record with a name of "class.<ClassName>". see SysCounter class.
         * KeyGenerator.GuidGen - GUID key generator.
         </pre>
         If not specified, the key must be set through appropriately mapped attribute(s).
      -->
   </xsd:complexType>

   <xsd:complexType name="FileStorageMapping">
      <xsd:attribute name="name" type="identifier"/>
      <!--
         The attribute name that is mapped to the file name.
      -->
      <xsd:attribute name="data" type="identifier"/>
      <!--
         The attribute name that is mapped to the contents of the file.
      -->
      <xsd:attribute name="keyGenerator" type="componentName"/>
      <!--
         The key generator component to use for generating names for files as they are persisted.

         @example
         KeyGenerator.GUIDGen
      -->
   </xsd:complexType>

   <xsd:complexType name="ServiceMapping">
   <!--
      Service Persistence Mapping
      @detail
      The service datasource type allows you to script the behaviour of object lifecycle events.
      These events include create, read, update and delete.  Two common use cases for the
      service datasource type are invoking Web Services through an integration service or
      invoking stored procedures in an RDBMS.

      This type of persistence mapping supports joins and automated caching.
      @context Persistence
   -->
      <xsd:sequence>
         <xsd:element name="KeyParts" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="KeyPart" minOccurs="1" maxOccurs="unbounded">
                  <!--
                     All objects require a key. The object key defines the structure of the
                     unique identifier of the object - the oid.
                  -->
                     <xsd:complexType>
                        <xsd:attribute name="type" type="identifier" use="required"/>
                        <!--
                           The key part type.
                        -->
                        <xsd:attribute name="attribute" type="identifier"/>
                        <!--
                           The optional attribute to which this key part is mapped.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="AttributeMappings" minOccurs="0" maxOccurs="1">
            <xsd:annotation>
               <xsd:appinfo>
                  <Collection ordered="false"/>
               </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="AttributeMapping" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:attribute name="name" type="identifier" use="required"/>
                        <!--
                           The name of the persistent attribute. Unmapped attributes are not persistent.
                        -->
                        <xsd:attribute name="attributes" type="xsd:string"/>
                        <!--
                           Association attributes that can be read without performing a separate
                           heterogeneous query on the associated class.
                           Not valid on primitive attributes.
                        -->
                        <xsd:attribute name="objectSourceKey" type="xsd:boolean" default="false"/>
                        <!--
                           True if the association source key is the object key; false if it is a foreign key.
                        -->
                        <xsd:attribute name="destinationKey" type="xsd:string"/>
                        <!--
                           The name of the destination key; unspecified to use the object key of
                           the associated class.
                        -->
                        <xsd:attribute name="maxLength" type="nonNegativeInt" default="0"/>
                        <!--
                           The maximum data length of a string or binary attribute; 0 for unlimited.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="SortKeys" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="SortKey" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:attribute name="unique" type="xsd:boolean" default="false"/>
                        <!--
                           True if this sort key is a unique key; false otherwise.
                        -->
                        <xsd:attribute name="attributes" type="xsd:string" use="required"/>
                        <!--
                           The key attributes, ordered. Use @ for object key; (<name> . #f) for descending sort.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="ReadMapping" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Case" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:element name="Read" minOccurs="1" maxOccurs="1">
                              <xsd:complexType>
                                 <xsd:sequence>
                                    <xsd:element name="Script" type="Script" minOccurs="1" maxOccurs="1"/>
                                    <!--
                                       The script to execute when this read mapping is triggered.
                                       @detail
                                       In this script, variables named after the tokens in the
                                       where clause pattern will be defined. See expr-case for
                                       more details.

                                       Additionally, the following variables are defined for all read
                                       mapping cases:

                                       class: The class on which the read was executed.

                                       attributes: The read clause attributes list, after dependencies have been
                                                   resolved, and security clauses, locking attributes, and type
                                                   code attributes have been added.

                                       where: The where clause that matched the where clause pattern. This where
                                              clause is the normalized where clause that is generated by the
                                              framework, and will likely differ from the where argument to
                                              Object'read.

                                       orderBy: The order by expression.

                                       count: See Object'read.

                                       offset: See Object'read.

                                       xlock: See Object'read.

                                       associations: List of attributes being read homogeneously. It is a
                                                     subset of "attributes".

                                       properties: An instance of PropertyHolder that contains the properties
                                                   from the .connections file for the current fragment.


                                       This script returns a transfer object or transfer objects that contain
                                       the data for the instances that were read. To return multiple transfer
                                       objects, this script may return a collection, a list, an iterator, or
                                       a generator function. Returning () means that no instances were read.

                                       A generator function is a function of a single argument; the argument
                                       is a special function called "yield". The yield function takes a single
                                       argument which is what the generator's return value will be. However,
                                       the yield function remembers from what point in the generator it was
                                       invoked, and the next time the generator is invoked it continues
                                       execution on the statement after yield.

                                       For example, the following generator returns the values of tobj1, tobj2,
                                       tobj3, tobj4, and tobj5 in sequence:

                                       <pre>
                                       (lambda (yield)
                                          (yield tobj1)
                                          (yield tobj2)
                                          (for-each
                                             yield
                                             `(,tobj3 ,tobj4 ,tobj5)
                                          )
                                       )
                                       </pre>

                                       The following example shows how to use an external data source that
                                       provides a cursor. (It is assumed that the variables "connection" and
                                       "resultCursor" are declared in the "variables" property.)

                                       <pre>
                                       (set! connection (open-connection))
                                       (set! resultCursor (connection'getResults ...some query...))
                                       ; return:
                                       (lambda (yield)
                                          (let nextResult ()
                                             (define result (resultCursor'getNext))
                                             (unless (null? result)
                                                (yield result)
                                                (nextResult)
                                             )
                                          )
                                       )
                                       </pre>

                                       In the preceeding example, the close script would execute
                                       (resultCursor'close) and (connection'close).

                                       The transfer objects must have a value for every primitive attribute
                                       in the list of attributes being read. Non-primitive attributes
                                       have a value only if that attribute has the association's
                                       foreign key; in this case the value is an OID. If the attribute is
                                       read homogeneously, then the value is a transfer object or collection
                                       of transfer objects.

                                       Additionally, the following special attributes must be set on the
                                       transfer object:

                                       :oid: Set to the OID of the instance read.

                                       :class: Set to the name of the class of the instance read. This can
                                                be (class'name), or it can be the name of one of the derived
                                                classes of class.

                                       If an orderBy expression is specified, (sort-by orderBy) may be
                                       used to construct a comparison function for ordering the results.
                                       @context ServiceMapping
                                    -->
                                 </xsd:sequence>
                              </xsd:complexType>
                           </xsd:element>
                           <xsd:element name="Close" minOccurs="0" maxOccurs="1">
                              <xsd:complexType>
                                 <xsd:sequence>
                                    <xsd:element name="Script" type="Script" minOccurs="1" maxOccurs="1"/>
                                    <!--
                                       The script to execute when the cursor over the read
                                       mapping is closed. The return value is ignored. The close
                                       script has access to all of the variables provided by the
                                       framework to the read script, including: class, attributes,
                                       where, etc.; the tokens from the where clause pattern; and
                                       the variables defined in the "variables" property.
                                    -->
                                 </xsd:sequence>
                              </xsd:complexType>
                           </xsd:element>
                        </xsd:sequence>
                        <xsd:attribute name="where" type="xsd:string"/>
                        <!--
                           The template where expression; blank matches any where clause, () matches empty where clause.
                        -->
                        <xsd:attribute name="variables" type="identifierList"/>
                        <!--
                           Read mapping variables, shared between the read and close scripts.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="CreateMapping" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Script" type="Script" minOccurs="1" maxOccurs="1"/>
                  <!--
                     The script to execute when this create mapping is triggered.
                     @detail
                     <pre>
                     In the script, the following variables will be defined:

                     this: A single transfer object or a collection of transfer objects,
                           depending on the value of the "batch" property.

                     properties: An instance of PropertyHolder that contains the properties
                                 from the .connections file for the current fragment.


                     On the transfer object, the following special attributes will be set:

                     :oid:   The OID of the instance being created, if a key generator is being used.
                              Otherwise, this OID will be () and it is the responsibility of this
                              script (or the external system) to generate the OID. The generated OID
                              will be communicated back to the framework by setting :oid.

                     :class: The string name of the class on which 'new was invoked (may be a sub-class
                              of this class.)

                     :event: "create"

                     Additionally, there will be one value in the transfer object for every
                     primitive attribute on the class with an attribute mapping. Non-primitive
                     attributes are set only if the attribute stores the association's foreign key.
                     In this case, the value will be the OID of the associated instance.

                     The return value of this script is ignored. However, the transfer object will
                     be examined after this script has finished execution. If special attribute :oid is
                     not (), then the instance OID will be set to that value. Also, if the class
                     has a locking attribute and the transfer object has a key whose name is the same
                     as the locking attribute, then the locking attribute value on the instance
                     will be set to the value from the transfer object.
                     </pre>
                  -->
               </xsd:sequence>
               <xsd:attribute name="batch" type="xsd:boolean" default="false"/>
               <!--
                  True if the mapping supports batch creates. If true, then "this" will be
                  a collection of create transfer objects. If false, then "this" will be a
                  single create transfer object.
               -->
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="UpdateMapping" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Case" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:element name="Script" type="Script" minOccurs="1" maxOccurs="1"/>
                           <!--
                              The script to execute when this update mapping is triggered.

                              In the script, the following variables will be defined:

                              this: A single transfer object or a collection of transfer objects,
                                    depending on the value of the "batch" property.

                              properties: An instance of PropertyHolder that contains the properties
                                          from the .connections file for the current fragment.


                              On the transfer object, the following special attributes will be set:

                              :oid:   The OID of the instance being updated.

                              :class: The string name of the class of the instance being updated (may be a sub-class
                                       of this class.)

                              :event: "update"

                              Additionally, there will be values in the transfer object for the
                              attributes being updated. The attributes that are included in the transfer
                              object are controlled by the "dirty" and "full" properties. Non-primitive attributes
                              are set only if the attribute stores the association's foreign key. In this
                              case, the value will be the OID of the associated instance.

                              The return value of this script is ignored. However, the transfer object will
                              be examined after this script has finished execution. If the class has a
                              locking attribute, then the locking attribute value on the instance
                              will be set to the value in the transfer object.

                              If there is an optimistic locking error, this script should throw the
                              exception using (throw-optimistic-lock <transfer-object>).
                           -->
                        </xsd:sequence>
                        <xsd:attribute name="attributes" type="identifierList"/>
                        <!--
                           The attributes handled by this update case.
                        -->
                        <xsd:attribute name="batch" type="xsd:boolean" default="false"/>
                        <!--
                           True if the mapping supports batch updates. If true, then "this"
                           will be a collection of update transfer objects. If false, then
                           "this" will be a single update transfer object.
                        -->
                        <xsd:attribute name="dirty" type="xsd:boolean" default="true"/>
                        <!--
                           Put only changed attributes into "this".
                           If false, a lazy load may be triggered to provide the missing values.
                        -->
                        <xsd:attribute name="full" type="xsd:boolean" default="false"/>
                        <!--
                           Put all persistent attributes into "this"; false to put only attributes listed in "attributes".
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="DeleteMapping" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Script" type="Script" minOccurs="1" maxOccurs="1"/>
                  <!--
                     The script to execute when this delete mapping is triggered.

                     In the script, the following variables will be defined:

                     this: A single transfer object or a collection of transfer objects,
                           depending on the value of the "batch" property.

                     properties: An instance of PropertyHolder that contains the properties
                                 from the .connections file for the current fragment.


                     On the transfer object, the following special attributes will be set:

                     :oid:   The OID of the instance being deleted.

                     :class: The string name of the class of the instance being deleted (may be a sub-class
                              of this class.)

                     :event: "delete"

                     If this class has a locking attribute, then there will be one value in the
                     transfer object, containing the locking attribute value.

                     The return value of this script is ignored.

                     If there is an optimistic locking error, this script should throw the
                     exception using (throw-optimistic-lock <transfer-object>).
                  -->
               </xsd:sequence>
               <xsd:attribute name="batch" type="xsd:boolean" default="false"/>
               <!--
                  True if the mapping supports batch deletes. If true, "this" will be a
                  collection of delete transfer objects. If false, then "this" will be a
                  single delete transfer object.
               -->
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="keyGenerator" type="componentName"/>
      <!--
         The key generator component to use.
         @example
         KeyGenerator.GUIDGen
      -->
      <xsd:attribute name="derived" type="xsd:boolean" default="false"/>
      <!--
         True to inherit mapping scripts from the base class; false to ignore the base mappings.
         The base mappings can be overridden by specifying a similar mapping on the derived class.
      -->
   </xsd:complexType>

   <xsd:complexType name="XMLMapping">
   <!--
      XML Persistence Mapping
      @context Persistence
   -->
      <xsd:sequence>
         <xsd:element name="AttributeMappings" minOccurs="0" maxOccurs="1">
         <!--
            Collection of XML Attribute Mappings
            @context XML
         -->
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="AttributeMapping" minOccurs="0" maxOccurs="unbounded">
                  <!--
                     Attribute Mapping to an XML element or attribute
                     @context XML
                  -->
                     <xsd:complexType>
                        <xsd:attribute name="name" type="identifier" use="required"/>
                        <!--
                           Attribute name.
                        -->
                        <xsd:attribute name="attribute" type="xsd:string"/>
                        <!--
                           XML attribute name.
                        -->
                        <xsd:attribute name="category" type="xsd:string"/>
                        <!--
                           Groups several XML files into a category.
                        -->
                        <xsd:attribute name="categoryAttributeXPath" type="xsd:string"/>
                        <!--
                           XPath notations for looking up category attribute value.
                        -->
                        <xsd:attribute name="reverse" type="xsd:boolean"/>
                        <!--
                           Specifies if the XML mapping should be reversed.

                           @detail
                           This is useful if one needs to traverse upwards in an XML hierarchy
                           such as determining which screen holds a certain menu, or which form
                           is associated with a specific control.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="primaryTag" type="xsd:string"/>
      <!--
         The primary tag in the XML mapping.
      -->
      <xsd:attribute name="path" type="xsd:string"/>
      <!--
         Space-separated xml node path.
      -->
      <xsd:attribute name="category" type="xsd:string"/>
      <!--
         Category used to load multiple xml files.
      -->
      <xsd:attribute name="xpath" type="xsd:string"/>
      <!--
         XPath notation XML node path.
      -->
      <xsd:attribute name="schemaPath" type="xsd:string"/>
      <!--
         Space delimited XML definition path.
      -->
   </xsd:complexType>

   <xsd:complexType name="CustomMapping">
      <xsd:sequence>
         <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
      </xsd:sequence>
      <xsd:anyAttribute processContents="lax"/>
   </xsd:complexType>

   <xsd:complexType name="CompositeMapping">
   <!--
      Persistence mapping providing a dynamic choice of possible alternative mappings at run-time.
      @detail
      The mapping for queries is taken from the ":shard" static attribute, containing (<mapping-name> . <fragment-name>).
      The retrieved instances contain an annotation with the same name ":shard" and the same data.
      This annotation is used also to create, update and delete the persistent instances.
      The mappings must have compatible object and foreign keys.
      It is possible to reference the keys of the nested mappings from another mapping as <mapping-name>#<key-name>.
      An empty <mapping-name> defaults to the referring mapping name.
      An empty <key-name> designates the object key.  
      @context Persistence
   -->
      <xsd:sequence>
         <xsd:element name="PersistenceMapping" minOccurs="0" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:choice>
                  <xsd:element name="RelationalMapping" type="RelationalMapping"/>
                  <xsd:element name="FileStorageMapping" type="FileStorageMapping"/>
                  <xsd:element name="ServiceMapping" type="ServiceMapping"/>
                  <xsd:element name="XMLMapping" type="XMLMapping"/>
                  <xsd:element name="CustomMapping" type="CustomMapping"/>
               </xsd:choice>
               <xsd:attribute name="dataSource" type="xsd:string" use="required"/>
               <!-- The data source of this mapping -->
               <xsd:attribute name="name" type="xsd:string"/>
               <!-- Mapping name used for shard matching and derivation. Defaults to the data source name. -->
               <xsd:attribute name="description" type="xsd:string"/>
               <!-- Mapping description. -->
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>

   <xsd:complexType name="PersistenceMapping">
   <!--
      A class persistence mapping specifies how its instances will be persisted in a given datasource.
      @detail
      A class has a persistence mapping if it is to be persisted by the object system.  The datasource
      where the class will be persisted is set in the DataSource property on the persistence mapping.
      The type of the selected datasource will dictate what sort of mapping is presented to the developer
      in NexJ Studio.
   -->
      <xsd:choice>
         <xsd:element name="RelationalMapping" type="RelationalMapping"/>
         <xsd:element name="FileStorageMapping" type="FileStorageMapping"/>
         <xsd:element name="ServiceMapping" type="ServiceMapping"/>
         <xsd:element name="XMLMapping" type="XMLMapping"/>
         <xsd:element name="CustomMapping" type="CustomMapping"/>
         <xsd:element name="CompositeMapping" type="CompositeMapping"/>
      </xsd:choice>
      <xsd:attribute name="dataSource" type="xsd:string" use="required"/>
      <!--
         Persistent datasource, in which the instances of this class are stored.
         @detail
         The type of the selected datasource will dictate what sort of mapping is presented to the developer
         in NexJ Studio.
      -->
      <xsd:attribute name="lockingAttribute" type="identifier"/>
      <!--
         Attribute used for optimistic locking. It must be of integer or long type and have an initializer.
      -->
      <xsd:attribute name="classCodeAttribute" type="identifier"/>
      <!--
         Attribute for determining an instance class.
         @detail
         The attribute value expression must be a unique constant within a given class hierarchy persisted in the same schema object.
      -->
      <xsd:attribute name="classCodeForced" type="xsd:boolean" default="false"/>
      <!--
         True to always apply the class code filter.
         @detail Use if the underlying schema object stores class codes that are not assigned in the domain model.
      -->
      <xsd:attribute name="fragmentAttribute" type="identifier"/>
      <!--
         String attribute providing the fragment name for unicast replication from the default fragment.
         @category Fragment
      -->
      <xsd:attribute name="fragmentReplication">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:enumeration value="unicast"/>
               <xsd:enumeration value="broadcast"/>
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <!--
         Fragment replication model: unicast - default to/from designated, broadcast - default to all.
         @category Fragment
      -->
      <xsd:attribute name="caching">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:enumeration value="instance"/>
               <xsd:enumeration value="class"/>
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <!--
         Caching mode: instance - individual instances are cached, class - all instances are cached.
         @detail
         Instance mode - Queries that are guaranteed to return <= 1 instance are cached if they return 1
         instance. A change to a given instance invalidates the cache for that particular instance.

         Class mode - All instances of the class are pre-read and cached. Queries are evaluated against this cache.
         If the query is an instance query (see above) and the cached instance count is > 64, then
         instance caching is used as well and the query is evaluated against the persistence store
         on cache miss. A change to an instance of the class or subclass invalidates the whole cache
         for the class.

         Heterogeneous joins (which are used for joining cached instances to a query) work with both types of caching.
         Caching is turned off for query subtrees that would require heterogeneous joins in the where clause
         if caching were used.
         @category Caching
      -->
   </xsd:complexType>

   <xsd:complexType name="Type">
      <xsd:sequence>
         <xsd:element name="Attributes" minOccurs="0" maxOccurs="1">
         <!--
            Collection of Attributes on a Class or Aspect
         -->
            <xsd:annotation>
               <xsd:appinfo>
                  <Collection ordered="false"/>
               </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Attribute" minOccurs="0" maxOccurs="unbounded">
                  <!--
                     An attribute is a structural characteristic of a class.
                     @detail
                     Attributes represent the structural characteristics of classes.  Class instances
                     have a slot for each attribute.  These attributes have many properties including name,
                     initializer, type, multiplicity and value (for calculated attributes).

                     E.g. The Person class may have an attribute named height with a type of double
                     and a multiplicity of non-collection.

                     Attribute types may be primitive (integer, string, ...) or refer to another associated
                     class within the domain model.

                     e.g. Person'homeAddress may be of type Address.

                     If a class has a base class, it inherits all of the attributes from that base.  Properties of
                     these inherited attributes may be overridden.

                     Attributes are mapped to locations in persistent data sources in the class'
                     persistence mapping.
                  -->
                     <xsd:complexType>
                        <xsd:attribute name="name" type="identifier" use="required"/>
                        <!--
                           Attribute name. Usually starts with lower case.
                           @detail
                           The attribute name must be unique within the class definition.
                        -->
                        <xsd:attribute name="caption" type="xsd:string"/>
                        <!--
                           String identifier of the user-friendly name of the attribute.
                           @detail
                           This property may refer to a string id for internationalization.
                        -->
                        <xsd:attribute name="compatible" type="xsd:boolean" default="false"/>
                        <!--
                           True if the attribute will remain backward compatible.
                        -->
                        <xsd:attribute name="visibility" type="visibility" default="public"/>
                        <!--
                           Public attribute values can be accessed by the clients through RPC, protected ones only within the server.
                           @category Security
                        -->
                        <xsd:attribute name="static" type="xsd:boolean" default="false"/>
                        <!--
                           True to share the attribute between all the objects, false to allocate it separately for each class instance.
                           @example
                           The StateEnum class may have a static attribute of OPEN so StateEnum'OPEN returns the caption of "Open".
                        -->
                        <xsd:attribute name="type" type="identifier" use="required"/>
                        <!--
                           Primitive type or another class within the domain model.
                           @example
                           string, integer, FinancialAccount, ...
                        -->
                        <xsd:attribute name="required" type="xsd:boolean" default="false"/>
                        <!--
                           True if the value cannot be empty for the instance to be committed.

                           @example
                           The lastName attribute on the Patient Class is required.
                        -->
                        <xsd:attribute name="collection" type="xsd:boolean" default="false"/>
                        <!--
                           True if the attribute stores a collection of objects.

                           @example
                           The addrs attribute on the Person Class is a collection.
                        -->
                        <xsd:attribute name="value" type="xsd:string"/>
                        <!--
                           Expression for calculating the attribute value.
                           @category Data
                           @detail Value is called the first time the object is referenced.  It works differently for
                           persisted vs. non-persisted attributes: a persisted attribute with a 'value' will be recalculated
                           whenever attributes that it depends on change (see dependency); a non-persisted attribute will only be recalculated when it is requested.
                           However, both will invalidate the value if the attributes they depend on change.  i.e. If you explicitly set the
                           value of an attribute, then change one of its dependencies, the next time you access
                           the attribute, it will call the value function.  Also, if you don't set the attribute's 'cached' property to true, the
                           attribute will be read-only.
                        -->
                        <xsd:attribute name="readOnly" type="xsd:boolean" default="false"/>
                        <!--
                           True to prohibit direct updates to the attribute value.
                        -->
                        <xsd:attribute name="cached" type="xsd:boolean"/>
                        <!--
                           True to cache a calculated attribute value on the instance, false to calculate it every time the value is needed.
                           @detail If not specified, the flag is set to true if reverse associations are available in the attribute dependency list.
                           A non-cached attribute is read-only.
                        -->
                        <xsd:attribute name="dependency" type="xsd:string"/>
                        <!--
                           Determines what other attributes this attribute's value is dependent on: attr1 (assoc2 attr2_1 ...) ...
                           @category Data

                           @example
                           The fullName attribute is dependent on the firstName and lastName attributes.
                        -->
                        <xsd:attribute name="orderBy" type="xsd:string"/>
                        <!--
                           Replaces the sort order used in the UI for this attribute: (attr1 . asc1) ... (attrN . ascN).
                           @category Data

                           @example
                           "" - order ascending on this attribute
                           (thisAttribute . #f) - order descending on the 'thisAttribute' attribute.
                           lastName firstName - order the fullName calculated attribute on the lastName then the firstName attributes ascending.
                           (@ doctor clinic name) - order the Patients based on their doctor's clinic's names.
                        -->
                        <xsd:attribute name="initializer" type="xsd:string"/>
                        <!--
                           Expression for setting the initial value of the attribute when the class is 'new'.
                           @category Data
                           @detail The initializer is called the first time the object is loaded if it hasn't been explicitly set.  It won't happen if the object isn't 'new'.
                        -->
                        <xsd:attribute name="validation" type="xsd:string"/>
                        <!--
                           Validation expression taking "this" and "value" as arguments and returning #f, a string id or a list of format arguments if the attribute is invalid.
                           @category Behavior
                           @detail
                           Class attributes may have values tested against a validation script before saving.
                           This validation will be consistently applied by the business model engine regardless
                           of where the value came from - UI, integration, automated processes...
                           The validation expression takes "this" (the current Class Instance) and
                           "value" (the value of the attribute) as it's arguments and returns #f, a string id
                           or a list of format arguments if the attribute is invalid.
                           @example
                           (if (not (number? value))
                              `("ids.numericValueError" ,value)
                           ) ; where ids.numericValueError is "Attribute must be numeric.  '{0}' is not valid."
                        -->
                        <xsd:attribute name="enumeration" type="identifier"/>
                        <!--
                           Class defining the set of valid values for this attribute. For primitive types, the "value" attribute is used.
                           @category Behavior
                        -->
                        <xsd:attribute name="constrained" type="xsd:boolean" default="false"/>
                        <!--
                           True if the values are constrained to those provided by the enumeration.
                           @category Behavior
                        -->
                        <xsd:attribute name="reverse" type="identifier"/>
                        <!--
                           Attribute in the associated class that refers back to this instance. (for non-primitive attributes only)
                           @detail
                           If the attribute is non-primitive (i.e. refers to an associated class), the reverse property optionally specifies
                           an attribute on the associated class that refers back to this instance.  If the association
                           is one-way then the reverse property will be left empty.

                           The Entity classes homePhone attribute is of type TelephoneNumber and has a reverse property of entity.
                           This means that we can navigate from Entity to TelephoneNumber via the Entity'homePhone attribute and from
                           TelephoneNumber to Entity via the TelephoneNumber'entity attribute in the Business Model.

                           If no reverse is specified, we will usually only navigate one-way.
                           @example
                           Association with a reverse
                                                 homePhone
                           Entity < - - - - - - - - - - - > TelephoneNumber
                                   entity

                           Association without a reverse
                                                 homePhone
                           Entity - - - - - - - - - - - - > TelephoneNumber
                        -->
                        <xsd:attribute name="where" type="xsd:string"/>
                        <!--
                           Where clause applied to the instances of the attribute type class.
                           @category Data
                        -->
                        <xsd:attribute name="cascade" type="cascade"/>
                        <!--
                           Determines the deletion logic for the instances associated through this attribute.
                           @category Behavior

                           @detail
                           Determines what will happen to associated class instances if the current instance is deleted.
                           Delete the associated instances, clear the association, or cancel the deletion if there are associated instances.
                        -->
                        <xsd:attribute name="readPrivilege" type="xsd:string"/>
                        <!--
                           Privilege required to read the value of this attribute.
                           @category Security
                        -->
                        <xsd:attribute name="updatePrivilege" type="xsd:string"/>
                        <!--
                           Privilege required to update the value of this attribute.
                           @category Security
                        -->
                        <xsd:attribute name="access" type="identifier"/>
                        <!--
                           Attribute on the same class, which value must be non-false to allow updates to this attribute.
                           @category Security
                        -->
                        <xsd:attribute name="category" type="xsd:string" default="domain"/>
                        <!--
                           Attribute category.
                        -->
                        <xsd:attribute name="description" type="xsd:string"/>
                        <!--
                           Attribute description.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Events" minOccurs="0" maxOccurs="1">
         <!--
            Collection of Events on a Class or Aspect.
            @detail
            Events are the behaviors of Classes or Aspects.  They may take a list of arguments. When invoked, they execute a series of Actions, which
            are script items or Java methods in a particular order.  Events
            always have a single 'main' action.  All other Event Actions are executed relative to the main
            action (and each other).  Event Actions can be overridden in subclasses.
         -->
            <xsd:annotation>
               <xsd:appinfo>
                  <Collection ordered="false"/>
               </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Event" minOccurs="0" maxOccurs="unbounded">
                  <!--
                     Events are the behaviors of Classes or Aspects.
                     @detail
                     Events are the behaviors of Classes or Aspects.  They may take a list of arguments.  When invoked, they execute a series of Actions, which
                     are script items or Java methods in a particular order.  Events
                     always have a single 'main' action.  All other Event Actions are executed relative to the main
                     action (and each other).  Event Actions can be overridden in subclasses.

                     All Classes (not Aspects) inherit from the base class - Object - which has no attributes and provides the following Events:
                        <pre>
                         * read(attributes where orderBy count offset xlock) - Static - Reads the specified instances of this class.
                         * openCursor(attributes where orderBy count offset xlock) - Static - Opens a cursor to read the specified instances of this class.
                         * load(attributes) - Loads on demand an undefined attribute.
                         * new(values) - Static - Creates and initializes an instance of this class.
                         * isNew() - Indicates if the instances state is New.
                         * create() - Invoked after the instance has been created and initialized.
                         * update() - Invoked after the instance has been created and initialized.
                         * delete() - Invoked to delete the instance.
                         * commit() - Invoked before the instance is committed.
                         * lock() - Invoked to lock the instance.
                         * old(attribute) - Gets the original value of an attribute as it was read.
                         * updated(attribute) - Checks whether an attribute value has been updated but not committed.
                         * :class() - Static - Returns the class object of this instance.
                         * :oid() - Returns the oid object of this instance.
                        </pre>
                   -->
                     <xsd:annotation>
                        <xsd:appinfo>
                           <Collection key="name args"/>
                        </xsd:appinfo>
                     </xsd:annotation>
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:element name="Arguments" minOccurs="0" maxOccurs="1">
                           <!--
                              Collection of optional argument details for an Event.  (Class or Aspect Events)
                              @detail
                              The list of event arguments are specified in the event's args property.  The
                              arguments collection provides the ability to enter further details about these
                              arguments such as their type or description.
                           -->
                              <xsd:complexType>
                                 <xsd:sequence>
                                    <xsd:element name="Argument" minOccurs="0" maxOccurs="unbounded">
                                    <!--
                                       Detailed specification of arguments for a class/aspect event.
                                       @detail
                                       If not specified here, the argument will be of type any, not required,
                                       non collection with no description.
                                    -->
                                       <xsd:complexType>
                                          <xsd:attribute name="name" type="identifier" use="required"/>
                                          <!--
                                             Argument name. Usually starts with lower case.
                                             @detail
                                             The argument name must exist and be unique within the args property.
                                          -->
                                          <xsd:attribute name="type" type="identifier" use="required"/>
                                          <!--
                                             Primitive type or a class within the domain model.
                                             @example
                                             string, integer, FinancialAccount...
                                          -->
                                          <xsd:attribute name="required" type="xsd:boolean" default="false"/>
                                          <!--
                                             True if the value cannot be null when calling the event.
                                          -->
                                          <xsd:attribute name="collection" type="xsd:boolean" default="false"/>
                                          <!--
                                             True if the argument provides a collection of objects.
                                          -->
                                          <xsd:attribute name="description" type="xsd:string"/>
                                          <!--
                                             Argument description.
                                             @detail
                                             If the argument is described here it will be used in any generated
                                             documentation.  This description will override @arg descriptions in schemeDoc
                                             for the event.  If only a schemeDoc @arg description is provided it will
                                             be used in generated documentation.
                                          -->
                                       </xsd:complexType>
                                    </xsd:element>
                                 </xsd:sequence>
                              </xsd:complexType>
                           </xsd:element>
                           <xsd:element name="Result" minOccurs="0" maxOccurs="1">
                           <!--
                              Optional result specification for an Event.
                              @detail
                              The result element provides the ability to provide constraints in the
                              event result type.
                           -->
                              <xsd:complexType>
                                 <xsd:attribute name="type" type="identifier" use="required"/>
                                 <!--
                                    Primitive type or a class within the domain model.
                                    @example
                                    string, integer, FinancialAccount...
                                 -->
                                 <xsd:attribute name="required" type="xsd:boolean" default="false"/>
                                 <!--
                                    True if the return value cannot be null.
                                 -->
                                 <xsd:attribute name="collection" type="xsd:boolean" default="false"/>
                                 <!--
                                    True if the return value is a collection of objects.
                                 -->
                                 <xsd:attribute name="description" type="xsd:string"/>
                                 <!--
                                    Result description.
                                    @detail
                                    If the result is described here it will be used in any generated
                                    documentation.  This description will override @return descriptions in schemeDoc
                                    for the event.  If only a schemeDoc @return description is provided it will
                                    be used in generated documentation.
                                 -->
                              </xsd:complexType>
                           </xsd:element>
                           <xsd:element name="Actions" minOccurs="0" maxOccurs="1">
                           <!--
                              Collection of Actions on an Event.  (Class or Aspect Events)
                              @detail
                              Actions are script items or Java methods executed in a particular order when a Class Event or Aspect Event is invoked.  Events
                              always have a single 'main' action.  All other actions are executed relative to the main
                              action (and each other).  Actions can be overridden in subclasses.  They may be conditionally executed.

                              To specify mutually exclusive actions within a group, use <group>:<action> as the action name.
                           -->
                              <xsd:complexType>
                                 <xsd:sequence>
                                    <xsd:element name="Action" minOccurs="0" maxOccurs="unbounded">
                                    <!--
                                       Script items for Class and Aspect Events.  e.g. Class.Event.Actions[]

                                       @detail
                                       Actions are script items or Java methods executed in a particular order when a Class Event or Aspect Event is invoked.  Events
                                       always have a single 'main' action.  All other actions are executed relative to the main
                                       action (and each other).  Actions can be overridden in subclasses.  They may be conditionally executed.

                                       To specify mutually exclusive actions within a group, use <group>:<action> as the action name.

                                       @context Class or Aspect
                                    -->
                                       <xsd:complexType>
                                          <xsd:complexContent>
                                             <xsd:extension base="Script">
                                                <xsd:attribute name="name" type="actionName" use="required"/>
                                                <!--
                                                   Action name. To specify mutually exclusive actions within a group, use <group>:<action>.
                                                -->
                                                <xsd:attribute name="type" use="required">
                                                   <xsd:simpleType>
                                                      <xsd:restriction base="xsd:string">
                                                         <xsd:enumeration value="main"/>
                                                         <xsd:enumeration value="before"/>
                                                         <xsd:enumeration value="after"/>
                                                         <xsd:enumeration value="around"/>
                                                      </xsd:restriction>
                                                   </xsd:simpleType>
                                                </xsd:attribute>
                                                <!--
                                                   Determines whether the action is executed before or after the main action, or it can wrap it ("around": use (call-next) to invoke the nested actions).
                                                -->
                                                <xsd:attribute name="relative" type="identifier"/>
                                                <!--
                                                   Action before which this action is placed. Use for specifying the action insertion point when subclassing an event.
                                                -->
                                                <xsd:attribute name="condition" type="xsd:string"/>
                                                <!--
                                                   Boolean expression determining whether the action is executed.
                                                -->
                                                <xsd:attribute name="method" type="qualJavaName"/>
                                                <!--
                                                   Java method implementing the action: <package>.<Class>.<method>(Instance|Metaclass, ..., ActionContext)
                                                -->
                                                <xsd:attribute name="description" type="xsd:string"/>
                                                <!--
                                                   Action description.
                                                -->
                                             </xsd:extension>
                                          </xsd:complexContent>
                                       </xsd:complexType>
                                    </xsd:element>
                                 </xsd:sequence>
                              </xsd:complexType>
                           </xsd:element>
                        </xsd:sequence>
                        <xsd:attribute name="name" type="identifier" use="required"/>
                        <!--
                           Event name. Usually starts with lower case.
                        -->
                        <xsd:attribute name="compatible" type="xsd:boolean" default="false"/>
                        <!--
                           True if the event will remain backward compatible.
                        -->
                        <xsd:attribute name="visibility" type="visibility" default="protected"/>
                        <!--
                           Public events can be invoked by the clients through RPC, protected ones only within the server.
                           @category Security
                        -->
                        <xsd:attribute name="static" type="xsd:boolean" default="false"/>
                        <!--
                           True if the event can update only shared state, false if it updates instance state.
                           @detail
                           Statics are available on instances and on the class metadata object.
                           @example
                           Object'read is a static event so (Person'read ...) and (myInstance'read ...) are
                           both valid.
                        -->
                        <xsd:attribute name="args" type="identifierList"/>
                        <!--
                           Ordered argument names.
                        -->
                        <xsd:attribute name="vararg" type="xsd:boolean" default="false"/>
                        <!--
                           True if the event accepts a variable number of arguments, which are stored as a list in the last argument.
                        -->
                        <xsd:attribute name="transaction" type="transaction"/>
                        <!--
                           Event's transactional behavior in the context of a caller's transaction (if any). One of supported, required, new, none, mandatory, unsupported.
                           @category Expert
                        -->
                        <xsd:attribute name="variables" type="xsd:string"/>
                        <!--
                           Variables shared among the actions: var1 (var2 init2) ... varN.
                        -->
                        <xsd:attribute name="privilege" type="xsd:string"/>
                        <!--
                           Privilege required to invoke this event.
                           @category Security
                        -->
                        <xsd:attribute name="access" type="identifier"/>
                        <!--
                           Attribute on the same class, which value must be non-false to allow invoking this event.
                           @category Security
                        -->
                        <xsd:attribute name="audit" type="xsd:boolean"/>
                        <!--
                           True to record RPC invocations of this event in the audit log.
                           @detail
                           Invocations over RPC are audited, side effects through business logic are not audited through the
                           use of this flag.
                           @category Security
                        -->
                        <xsd:attribute name="category" type="xsd:string" default="domain"/>
                        <!--
                           Event category.
                        -->
                        <xsd:attribute name="description" type="xsd:string"/>
                        <!--
                           Event description.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="where" type="xsd:string"/>
      <!--
         Read restriction on the instances of the class.
      -->
      <xsd:attribute name="validation" type="xsd:string"/>
      <!--
         Validation expression taking "this" argument and returning #f, a string indentifier or a list of format arguments if the instance is invalid.
      -->
      <xsd:attribute name="aspects" type="aspectList"/>
      <!--
         List of names of aspects to include in or exclude from (if prefixed with !) this class.  If an
         aspect is included, the aspect's attributes and events are appended to this class'.
         @category Aspect
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Type description.
      -->
   </xsd:complexType>

   <xsd:complexType name="Aspect">
      <xsd:complexContent>
         <xsd:extension base="Type">
            <xsd:sequence>
               <xsd:element name="PersistenceMappings" minOccurs="0" maxOccurs="1">
                  <xsd:complexType>
                     <xsd:sequence>
                        <xsd:element name="PersistenceMapping" type="PersistenceMapping" minOccurs="0" maxOccurs="unbounded"/>
                     </xsd:sequence>
                  </xsd:complexType>
               </xsd:element>
            </xsd:sequence>
            <xsd:attribute name="pointcuts" type="xsd:string"/>
            <!--
               List of name patterns (with * and ?) of classes, where to include or exclude (if prefixed with !) this aspect.
               @category Aspect
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="Class">
      <xsd:complexContent>
         <xsd:extension base="Type">
            <xsd:sequence>
               <xsd:element name="PersistenceMapping" type="PersistenceMapping" minOccurs="0" maxOccurs="1"/>
            </xsd:sequence>
            <xsd:attribute name="base" type="identifier"/>
            <!--
               Base class, the definition of which is inherited.
            -->
            <xsd:attribute name="visibility" type="visibility" default="public"/>
            <!--
               Public to participate in RPC, protected for in-process use only.
            -->
            <xsd:attribute name="caption" type="xsd:string"/>
            <!--
               String indentifier of the user-friendly name of the class.
            -->
            <xsd:attribute name="nameAttribute" type="identifier"/>
            <!--
               Attribute that provides the name of the instance, e.g. contact fullName.
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="Enumeration">
      <xsd:sequence>
         <xsd:element name="Locales" minOccurs="0" maxOccurs="1">
         <!--
            @context Enumeration
         -->
            <xsd:annotation>
               <xsd:appinfo>
                  <Collection ordered="false"/>
               </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Locale" minOccurs="0" maxOccurs="unbounded">
                  <!--
                     @context Enumeration
                  -->
                     <xsd:complexType>
                        <xsd:attribute name="name" use="required">
                           <xsd:simpleType>
                              <xsd:restriction base="xsd:string">
                                 <xsd:maxLength value="8"/>
                              </xsd:restriction>
                           </xsd:simpleType>
                        </xsd:attribute>
                        <!--
                           Locale name.
                        -->
                        <xsd:attribute name="caption" use="required">
                           <xsd:simpleType>
                              <xsd:restriction base="xsd:string">
                                 <xsd:maxLength value="100"/>
                              </xsd:restriction>
                           </xsd:simpleType>
                        </xsd:attribute>
                        <!--
                           Localized enumeration caption.
                        -->
                        <xsd:attribute name="description">
                           <xsd:simpleType>
                              <xsd:restriction base="xsd:string">
                                 <xsd:maxLength value="255"/>
                              </xsd:restriction>
                           </xsd:simpleType>
                        </xsd:attribute>
                        <!--
                           Localized enumeration description.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Values" minOccurs="0" maxOccurs="1">
         <!--
            @context Enumeration
         -->
            <xsd:annotation>
               <xsd:appinfo>
                  <Collection ordered="false"/>
               </xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Value" minOccurs="0" maxOccurs="unbounded">
                  <!--
                     One of the list of values for an Enumeration.
                     @detail
                     Enumerations are a special type of Class that provide a list of values along with localizable captions.
                     @example Our enumeration is called DayOfWeekEnum.  It has a list of values named MONDAY, TUESDAY, WEDNESDAY...
                     the code values are "1", "2", "3", ... Each of the values has French and English captions.
                     In usage, (DayOfWeekEnum'MONDAY) returns "1" which you might use in a comparison like (= currentDay (DayOfWeekEnum'MONDAY)) if currentDay was simply a String value.
                     To get an instance of the value use the 'get' syntax as in (DayOfWeekEnum'get'MONDAY).
                     To get the caption of the value, use the caption property, as in ((DayOfWeekEnum'get'MONDAY)'caption).  This
                     will return the caption in the current invocation context's locale.
                     @context Enumeration
                  -->
                     <xsd:complexType>
                        <xsd:sequence>
                           <xsd:element name="Locales" minOccurs="0" maxOccurs="1">
                           <!--
                              @context Enumeration Value
                           -->
                              <xsd:annotation>
                                 <xsd:appinfo>
                                    <Collection ordered="false"/>
                                 </xsd:appinfo>
                              </xsd:annotation>
                              <xsd:complexType>
                                 <xsd:sequence>
                                    <xsd:element name="Locale" minOccurs="0" maxOccurs="unbounded">
                                    <!--
                                       @context Enumeration Value
                                    -->
                                       <xsd:complexType>
                                          <xsd:attribute name="name" use="required">
                                             <xsd:simpleType>
                                                <xsd:restriction base="xsd:string">
                                                   <xsd:maxLength value="8"/>
                                                </xsd:restriction>
                                             </xsd:simpleType>
                                          </xsd:attribute>
                                          <!--
                                             Locale name
                                          -->
                                          <xsd:attribute name="caption" use="required">
                                             <xsd:simpleType>
                                                <xsd:restriction base="xsd:string">
                                                   <xsd:maxLength value="100"/>
                                                </xsd:restriction>
                                             </xsd:simpleType>
                                          </xsd:attribute>
                                          <!--
                                             Localized enumeration caption.
                                          -->
                                          <xsd:attribute name="shortCaption">
                                             <xsd:simpleType>
                                                <xsd:restriction base="xsd:string">
                                                   <xsd:maxLength value="20"/>
                                                </xsd:restriction>
                                             </xsd:simpleType>
                                          </xsd:attribute>
                                          <!--
                                             Localized enumeration short caption.
                                          -->
                                       </xsd:complexType>
                                    </xsd:element>
                                 </xsd:sequence>
                              </xsd:complexType>
                           </xsd:element>
                        </xsd:sequence>
                        <xsd:attribute name="name" type="identifier" use="required"/>
                        <!--
                           Unique value name. If the enumerated value's hasBehavior property is true,
                           this is also the name of a public static read-only attribute on the enumeration class containing the constant code value.
                        -->
                        <xsd:attribute name="value" use="required">
                           <xsd:simpleType>
                              <xsd:restriction base="xsd:string">
                                 <xsd:maxLength value="50"/>
                              </xsd:restriction>
                           </xsd:simpleType>
                        </xsd:attribute>
                        <!--
                           Enumeration code value.
                        -->
                        <xsd:attribute name="hasBehavior" type="xsd:boolean" default="false"/>
                        <!--
                           True if business logic is associated with this value.
                           @detail It also means that a public static read-only
                           attribute will be added to the enumerated class by the name of the 'name' property and containing the 'value' property.
                           @example (DayOfWeekEnum'MONDAY) will return "1".  Where: DaysOfWeekEnum is the enumeration, MONDAY is the name
                           of one of the values, and "1" is the code value.
                        -->
                        <xsd:attribute name="behaveAsValue" type="xsd:string"/>
                        <!--
                           Specifies a value with hasBehavior=true, to which this one is synonymous.
                        -->
                        <xsd:attribute name="externalValue">
                           <xsd:simpleType>
                              <xsd:restriction base="xsd:string">
                                 <xsd:maxLength value="50"/>
                              </xsd:restriction>
                           </xsd:simpleType>
                        </xsd:attribute>
                        <!--
                           Optional external integration value.
                        -->
                        <xsd:attribute name="parentValue">
                           <xsd:simpleType>
                              <xsd:restriction base="xsd:string">
                                 <xsd:maxLength value="50"/>
                              </xsd:restriction>
                           </xsd:simpleType>
                        </xsd:attribute>
                        <!--
                           Parent value corresponding to this value.
                        -->
                        <xsd:attribute name="hideable" type="xsd:boolean" default="true"/>
                        <!--
                           True if the value can be hidden from the UI.
                        -->
                        <xsd:attribute name="deletable" type="xsd:boolean" default="false"/>
                        <!--
                           True if the value can be deleted.
                        -->
                        <xsd:attribute name="codeUpdateable" type="xsd:boolean" default="false"/>
                        <!--
                           True if value attributes can be updated at run time.
                        -->
                        <xsd:attribute name="displayUpdateable" type="xsd:boolean" default="true"/>
                        <!--
                           True if the display data for the value can be modified at run time.
                        -->
                        <xsd:attribute name="upgradeUpdateable" type="xsd:boolean" default="true"/>
                        <!--
                           True if the value can be automatically upgraded.
                        -->
                        <xsd:attribute name="description">
                           <xsd:simpleType>
                              <xsd:restriction base="xsd:string">
                                 <xsd:maxLength value="255"/>
                              </xsd:restriction>
                           </xsd:simpleType>
                        </xsd:attribute>
                        <!--
                           Enumeration value description.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="base" type="identifier"/>
      <!--
         Optional base enumeration class with "value", class code and optional "caption", "displayOrder", "parent" and "children" attributes.
      -->
      <xsd:attribute name="parent" type="identifier"/>
      <!--
         Parent enumeration name, if any.
      -->
      <xsd:attribute name="association" type="identifier"/>
      <!--
         The name of the association from the parent enumeration to this one.
      -->
      <xsd:attribute name="reverse" type="identifier"/>
      <!--
         The name of the association from this enumeration to the parent one.
      -->
      <xsd:attribute name="typeCode" use="required">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:maxLength value="20"/>
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <!--
         Enumeration type code value, uniquely identifying the enumeration.
      -->
      <xsd:attribute name="userQuickpick" type="xsd:boolean" default="false"/>
      <!--
         True if the users can add personalized enumeration values for display in the UI.
      -->
      <xsd:attribute name="allowNewValues" type="xsd:boolean" default="false"/>
      <!--
         True if the administrator can add create new values at run time.
      -->
      <xsd:attribute name="upgradeable" type="xsd:boolean" default="true"/>
      <!--
         True if the enumeration can be automatically upgraded.
      -->
      <xsd:attribute name="classification" default="system">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:enumeration value="system"/>
               <!--
                  Values are are created at design-time and only used in code for business logic.  Values never get displayed in user interfaces.
               -->
               <xsd:enumeration value="sysDisplay"/>
               <!--
                  Values are not editable at run-time, critical for business logic and system behaviour.  Values can be displayed to the user (i.e. exposed via user interfaces).
               -->
               <xsd:enumeration value="sysEdit"/>
               <!--
                  Values are critical to business function, but certain aspects can be modified at run-time.
               -->
               <xsd:enumeration value="custom"/>
               <!--
                  Values are only added at run-time by users.
               -->
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <!--
         Enumeration classification string.
      -->
      <xsd:attribute name="description" use="required">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:maxLength value="255"/>
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <!--
         Enumeration description.
      -->
   </xsd:complexType>

   <xsd:group name="Activity">
      <xsd:choice>
         <xsd:element name="Script" type="ScriptStep"/>
         <xsd:element name="Goto" type="Goto"/>
         <xsd:element name="Action" type="Action"/>
         <xsd:element name="Timeout" type="Timeout"/>
         <xsd:element name="Decision">
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Decision">
                     <xsd:sequence>
                        <xsd:element name="Branch" minOccurs="2" maxOccurs="unbounded">
                           <xsd:complexType>
                              <xsd:complexContent>
                                 <xsd:extension base="Decision_Branch">
                                    <xsd:group ref="Activity" minOccurs="0" maxOccurs="unbounded"/>
                                 </xsd:extension>
                              </xsd:complexContent>
                           </xsd:complexType>
                        </xsd:element>
                     </xsd:sequence>
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Loop">
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Loop">
                     <xsd:group ref="Activity" minOccurs="0" maxOccurs="unbounded"/>
                     <xsd:attribute name="collection" type="xsd:string" use="required"/>
                     <!--
                        Expression returning a list, collection, or iterator.
                        @example
                        '(1 1 2 3 5)
                     -->
                     <xsd:attribute name="variable" type="identifier" use="required"/>
                     <!--
                        The name of the workflow variable into which the current item will be placed.
                     -->
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Semaphore">
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Semaphore">
                     <xsd:group ref="Activity" minOccurs="0" maxOccurs="unbounded"/>
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="TryCatch">
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="TryCatch">
                     <xsd:sequence>
                        <xsd:element name="Try" minOccurs="0" maxOccurs="1">
                           <xsd:complexType>
                              <xsd:group ref="Activity" minOccurs="0" maxOccurs="unbounded"/>
                           </xsd:complexType>
                        </xsd:element>
                        <xsd:element name="Catch" minOccurs="0" maxOccurs="unbounded">
                           <xsd:complexType>
                              <xsd:complexContent>
                                 <xsd:extension base="Catch">
                                    <xsd:group ref="Activity" minOccurs="0" maxOccurs="unbounded"/>
                                 </xsd:extension>
                              </xsd:complexContent>
                           </xsd:complexType>
                        </xsd:element>
                        <xsd:element name="Finally" minOccurs="0" maxOccurs="1" type="Script"/>
                        <!--
                           A script that is run when the flow leaves the try block, either normally or through an exception.
                           @context Workflow
                        -->
                     </xsd:sequence>
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Join">
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Join">
                     <xsd:sequence>
                        <xsd:element name="Activity" minOccurs="1" maxOccurs="unbounded">
                        <!--
                           Step within a Join of a Workflow.  e.g. Activity, TimerEvent, Try, Branch...
                        -->
                           <xsd:complexType>
                              <xsd:group ref="Activity" minOccurs="0" maxOccurs="unbounded"/>
                              <xsd:attribute name="args" type="xsd:string"/>
                              <!--
                                 A collection of values to be passed individually to each of the threads.
                              -->
                              <xsd:attribute name="variable" type="identifier"/>
                              <!--
                                 The name of the Workflow variable that will be used for the thread argument of this Fork/Join block.
                              -->
                           </xsd:complexType>
                        </xsd:element>
                     </xsd:sequence>
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Assignment" type="Assignment"/>
         <xsd:element name="Queue">
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Queue">
                     <xsd:choice minOccurs="0" maxOccurs="unbounded">
                        <xsd:element name="TimerEvent">
                           <xsd:complexType>
                              <xsd:complexContent>
                                 <xsd:extension base="Queue_TimerEvent">
                                    <xsd:group ref="Activity" minOccurs="0" maxOccurs="unbounded"/>
                                 </xsd:extension>
                              </xsd:complexContent>
                           </xsd:complexType>
                        </xsd:element>
                        <xsd:element name="ClassEvent">
                           <xsd:complexType>
                              <xsd:complexContent>
                                 <xsd:extension base="Queue_ClassEvent">
                                    <xsd:group ref="Activity" minOccurs="0" maxOccurs="unbounded"/>
                                 </xsd:extension>
                              </xsd:complexContent>
                           </xsd:complexType>
                        </xsd:element>
                        <xsd:element name="ProcessEvent">
                           <xsd:complexType>
                              <xsd:complexContent>
                                 <xsd:extension base="Queue_ProcessEvent">
                                    <xsd:group ref="Activity" minOccurs="0" maxOccurs="unbounded"/>
                                 </xsd:extension>
                              </xsd:complexContent>
                           </xsd:complexType>
                        </xsd:element>
                        <xsd:element name="ManualEvent">
                           <xsd:complexType>
                              <xsd:complexContent>
                                 <xsd:extension base="Queue_ManualEvent">
                                    <xsd:group ref="Activity" minOccurs="0" maxOccurs="unbounded"/>
                                 </xsd:extension>
                              </xsd:complexContent>
                           </xsd:complexType>
                        </xsd:element>
                     </xsd:choice>
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="UIAction" type="UIAction"/>
         <xsd:any processContents="lax"/>
      </xsd:choice>
   </xsd:group>

   <xsd:complexType name="Workflow">
      <xsd:group ref="Activity" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:attribute name="class" type="identifier" use="required"/>
      <!--
         Primary class, providing access to the domain model.
      -->
      <xsd:attribute name="attributes" type="xsd:string"/>
      <!--
         Attributes of the primary class instance to load automatically when the workflow is run: attr1 (assoc2 attr2_1 ... attr2_M) ... attrN.
      -->
      <xsd:attribute name="association" type="identifierList"/>
      <!--
         Association path from the primary workflow class to the class with the triggering event: attr1 ... attrN.
      -->
      <xsd:attribute name="event" type="identifier"/>
      <!--
         Event which triggers the workflow.
      -->
      <xsd:attribute name="args" type="nonNegativeInt"/>
      <!--
         Event argument count.
      -->
      <xsd:attribute name="condition" type="xsd:string"/>
      <!--
         Condition under which the workflow is started when the event is invoked. Relative to the association end class.
      -->
      <xsd:attribute name="variables" type="identifierList"/>
      <!--
         Workflow variables: var1 var2 ... varN.
      -->
      <xsd:attribute name="privileged" type="xsd:boolean" default="false"/>
      <!--
         True to execute the workflow in privileged mode (without security restrictions).
         @category Security
      -->
      <xsd:attribute name="caption" type="xsd:string"/>
      <!--
         String indentifier for caption display in the UI.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Workflow description.
      -->
      <xsd:attribute name="layout" type="xsd:string"/>
   </xsd:complexType>

   <xsd:complexType name="WorkflowQueue">
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Worklow queue description.
         @category Common
      -->
      <xsd:attribute name="class" type="identifier"/>
      <!--
         Workflow queue implementation.
         @category Common
      -->
      <xsd:attribute name="readPrivilege" type="xsd:string"/>
      <!--
         Privilege required to read from this queue.
         @category Security
      -->
      <xsd:attribute name="updatePrivilege" type="xsd:string"/>
      <!--
         Privilege required to add items to this queue.
         @category Security
      -->
      <xsd:attribute name="scheduler" type="xsd:string"/>
      <!--
         Name of the scheduler for this queue. By default, no scheduler is used.
         @category Common
      -->
      <xsd:attribute name="priority" type="xsd:int"/>
      <!--
         The relative priority of this queue.
         @category Scheduler
      -->
      <xsd:attribute name="concurrency" type="nonNegativeInt"/>
      <!--
         The maximum number of assignments that may be scheduled concurrently from this queue.
         @category Scheduler
      -->
      <xsd:attribute name="rate" type="nonNegativeDouble"/>
      <!--
         The maximum number of assignments that may be scheduled from this queue in one minute.
         @category Scheduler
      -->
   </xsd:complexType>

   <xsd:complexType name="Component">
      <xsd:sequence>
         <xsd:element name="Factory" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:complexContent>
                  <xsd:extension base="Component">
                     <xsd:attribute name="method" type="qualJavaName"/>
                     <!--
                        Java method implementing the component: <package>.<Class>.<method>(Instance|Metaclass, ..., ActionContext)
                     -->
                  </xsd:extension>
               </xsd:complexContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Properties" type="ComponentProperties" minOccurs="0" maxOccurs="1"/>
         <!--
            @context Component
         -->
      </xsd:sequence>
      <xsd:attribute name="activation" use="required">
         <xsd:simpleType>
            <xsd:restriction base="xsd:string">
               <xsd:enumeration value="singleton"/>
               <!--
                  Only one instance gets created that is shared between all threads.
               -->
               <xsd:enumeration value="context"/>
               <!--
                  One instance is created per invocation context.
               -->
               <xsd:enumeration value="new"/>
               <!--
                  A new instance is always created upon every activation request.
               -->
            </xsd:restriction>
         </xsd:simpleType>
      </xsd:attribute>
      <!--
         Component activation model.
      -->
      <xsd:attribute name="type" type="qualJavaName" use="required"/>
      <!--
         Java type associated with the component.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Description of the Component.
      -->
   </xsd:complexType>

   <xsd:complexType name="ComponentProperties">
   <!--
      @context Component
   -->
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
         <xsd:element name="Property">
         <!--
            @context Component
         -->
            <xsd:complexType mixed="true">
               <xsd:sequence>
                  <xsd:element name="Component" type="Component" minOccurs="0" maxOccurs="1"/>
               </xsd:sequence>
               <xsd:attribute name="name" type="identifier" use="required"/>
               <!--
                  Uniquely identifies the Component Property.
               -->
               <xsd:attribute name="directive" type="directive"/>
               <!--
                  A conditional directive determining the operation to apply to the property specified in "condition".

                  @detail
                  If the operation is set to "if" or "ifnot", the property can be null.
                  "ifdef" means "if defined". "ifndef" means "if not defined".
                  If the operation is set to either, the property must not be null.

                  @example
                  "if", "ifnot", "ifdef", "ifndef"
               -->
               <xsd:attribute name="condition" type="xsd:string"/>
               <!--
                  The property to which the directive is applied.

                  @detail
                  The property specified here must be prefixed with "-Dnexj" if specified
                  on the JVM command line, but not if specified in the server file.

                  @example
                  condition=""database.port.enabled" ... "-Dnexj.database.port.enabled=1"
               -->
               <xsd:attribute name="override" type="xsd:string"/>
               <!--
                  This value takes precedence over the property specified in the metadata.
               -->
               <xsd:attribute name="description" type="xsd:string"/>
               <!--
                  Description of the Component Property.
               -->
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Collection">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Item" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType mixed="true">
                        <xsd:sequence>
                           <xsd:element name="Component" type="Component" minOccurs="0" maxOccurs="1"/>
                        </xsd:sequence>
                        <xsd:attribute name="directive" type="directive"/>
                        <!--
                           An conditional directive determining the operation to apply to the property specified in 'condition'.

                           @detail
                           If the operation is set to "if" or "ifnot", the property can be null.
                           "ifdef" means "if defined". "ifndef" means "if not defined".
                           If the operation is set to either, the property must not be null.

                           @example
                           "if", "ifnot", "ifdef", "ifndef"
                        -->
                        <xsd:attribute name="condition" type="xsd:string"/>
                        <!--
                           The property to which the directive is applied.

                           @detail
                           The property specified here must be prefixed with "-Dnexj"
                           unless the property is specfied in the server file.

                           @example
                           "-Dnexj.database.port.enabled=1"
                        -->
                        <xsd:attribute name="override" type="xsd:string"/>
                        <!--
                           This value takes precedence over the property specified in the metadata.
                        -->
                        <xsd:attribute name="description" type="xsd:string"/>
                        <!--
                           Description of the Collection Item.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
               <xsd:attribute name="name" type="identifier" use="required"/>
               <!--
                  Uniquely identifies the Collection.
               -->
               <xsd:attribute name="directive" type="directive"/>
               <!--
                  An conditional directive determining the operation to apply to the property specified in 'condition'.

                  @detail
                  If the operation is set to "if" or "ifnot", the property can be null.
                  "ifdef" means "if defined". "ifndef" means "if not defined".
                  If the operation is set to either, the property must not be null.

                  @example
                  "if", "ifnot", "ifdef", "ifndef"
               -->
               <xsd:attribute name="condition" type="xsd:string"/>
               <!--
                  The property to which the directive is applied.

                  @detail
                  The property specified here must be prefixed with "-Dnexj"
                  unless the property is specfied in the server file.

                  @example
                  "-Dnexj.database.port.enabled=1"
               -->
               <xsd:attribute name="description" type="xsd:string"/>
               <!--
                  Description of the Collection.
               -->
            </xsd:complexType>
         </xsd:element>
      </xsd:choice>
   </xsd:complexType>

   <xsd:complexType name="ExternalLibrary">
      <xsd:sequence>
         <xsd:element name="Files" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="File" minOccurs="0" maxOccurs="unbounded">
                  <!--
                     ExternalLibraries reference jar files located in the project's /lib folder.  For documentation purposes only.
                     @context ExternalLibrary
                  -->
                     <xsd:complexType>
                        <xsd:attribute name="name" type="xsd:string" use="required"/>
                        <!--
                           Name of the JAR file stored under the project "/lib" folder.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Licenses" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="License" minOccurs="0" maxOccurs="unbounded">
                     <xsd:complexType>
                        <xsd:attribute name="name" type="xsd:string" use="required"/>
                        <!--
                           Name of the license text file.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="version" type="xsd:string"/>
      <!--
         Library version.
      -->
      <xsd:attribute name="vendor" type="xsd:string"/>
      <!--
         Library vendor name.
      -->
      <xsd:attribute name="url" type="xsd:anyURI"/>
      <!--
         Library web page, download address, vendor contact e-mail or other relevant URL.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         External library description.
      -->
   </xsd:complexType>

   <xsd:complexType name="FlowMacro">
      <xsd:sequence>
         <xsd:element name="Arguments" minOccurs="0" maxOccurs="1">
         <!--
            Collection of Arguments that Custom Action will expect.
            @context Custom Action
         -->
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Argument" minOccurs="0" maxOccurs="unbounded">
                  <!--
                     Argument to pass to a Custom Action.
                     @context Custom Action
                  -->
                     <xsd:complexType>
                        <xsd:attribute name="name" type="identifier" use="required"/>
                        <!--
                           Argument name.
                        -->
                        <xsd:attribute name="type" type="flowMacroArgType" use="required"/>
                        <!--
                           Argument type. Arguments of type "any" and "list" should be specified as Scheme expressions, the other ones are taken literally.
                        -->
                        <xsd:attribute name="default" type="xsd:string"/>
                        <!--
                           Default argument value. If not specified, the argument is required.
                        -->
                        <xsd:attribute name="description" type="xsd:string" use="required"/>
                        <!--
                           Argument description displayed in the property view.
                        -->
                        <xsd:attribute name="category" type="xsd:string" default="Common"/>
                        <!--
                           Argument category displayed in the property view.
                        -->
                     </xsd:complexType>
                  </xsd:element>
               </xsd:sequence>
            </xsd:complexType>
         </xsd:element>
         <xsd:element name="Script" type="Script"/>
         <!--
            @context Custom Action
         -->
      </xsd:sequence>
      <xsd:attribute name="caption" type="xsd:string" use="required"/>
      <!--
         Caption displayed in the palette.
      -->
      <xsd:attribute name="tooltip" type="xsd:string" use="required"/>
      <!--
         Tooltip displayed in the palette.
      -->
      <xsd:attribute name="icon" type="xsd:string" use="required"/>
      <!--
         Icon name (no size prefix).
      -->
      <xsd:attribute name="workflow" type="xsd:boolean" default="false"/>
      <!--
         True if the action can be used in a workflow.
      -->
      <xsd:attribute name="service" type="xsd:boolean" default="false"/>
      <!--
         True if the action can be used in an integration service.
      -->
      <xsd:attribute name="etl" type="xsd:boolean" default="false"/>
      <!--
         True if the action can be used in an ETL activity.
      -->
      <xsd:attribute name="description" type="xsd:string"/>
      <!--
         Action description.
      -->
   </xsd:complexType>

   <xsd:complexType name="RelationalDatabaseConnection">
      <xsd:complexContent>
         <xsd:extension base="DataSourceConnection">
            <xsd:sequence>
               <xsd:element name="Properties" type="CustomProperties" minOccurs="0" maxOccurs="1"/>
               <!--
                  @context Connection
               -->
               <xsd:element name="Fragments" minOccurs="0" maxOccurs="1">
               <!--
                  @context Database
               -->
                  <xsd:complexType>
                     <xsd:sequence>
                        <xsd:element name="Fragment" minOccurs="0" maxOccurs="unbounded">
                        <!--
                          @context Database
                        -->
                           <xsd:complexType>
                              <xsd:sequence>
                                 <xsd:element name="Properties" type="CustomProperties" minOccurs="0" maxOccurs="1"/>
                              </xsd:sequence>
                              <xsd:attribute name="name" type="fragmentName" use="required"/>
                              <!--
                                 Fragment name.
                              -->
                              <xsd:attribute name="alias" type="alias"/>
                              <!--
                                 Overrides the default JNDI name of the fragment. The default name is the fragment name concatenated to the datasource alias.
                              -->
                              <xsd:attribute name="host" type="xsd:string"/>
                              <!--
                                 Database server host name.
                              -->
                              <xsd:attribute name="port" type="xsd:unsignedShort"/>
                              <!--
                                 Database server port number (optional).
                              -->
                              <xsd:attribute name="instance" type="xsd:string"/>
                              <!--
                                 Database server instance name (optional).
                              -->
                              <xsd:attribute name="database" type="xsd:string"/>
                              <!--
                                 Database name. Defaults
                              -->
                              <xsd:attribute name="user" type="xsd:string"/>
                              <!--
                                 Database user name.
                              -->
                              <xsd:attribute name="password" type="password"/>
                              <!--
                                 Database user password.
                              -->
                              <xsd:attribute name="minPoolSize" type="nonNegativeInt"/>
                              <!--
                                 Minimum database connection pool size per server.
                                 @category Performance
                              -->
                              <xsd:attribute name="maxPoolSize" type="positiveInt"/>
                              <!--
                                 Maximum database connection pool size per server.
                                 @category Performance
                              -->
                              <xsd:attribute name="statementCacheSize" type="positiveInt"/>
                              <!--
                                 The prepared SQL statement cache size.
                                 @category Performance
                              -->
                              <xsd:attribute name="queryTimeout" type="nonNegativeInt"/>
                              <!--
                                 The query timeout in seconds (0 for unlimited).
                                 @category Performance
                              -->
                              <xsd:attribute name="warningTimeout" type="nonNegativeLong"/>
                              <!--
                                 The long-running query warning timeout in milliseconds (0 for unlimited). Overridable by the nexj.dataSourceConnection.<name>.warningTimeout system property.
                                 @category Performance
                              -->
                           </xsd:complexType>
                        </xsd:element>
                     </xsd:sequence>
                  </xsd:complexType>
               </xsd:element>
               <xsd:element name="SQLHook" type="Component" minOccurs="0" maxOccurs="1"/>
            </xsd:sequence>
            <xsd:attribute name="alias" type="alias"/>
            <!--
               Overrides the default JNDI name of the default fragment. The default name is the alias on the datasource.
            -->
            <xsd:attribute name="unicode" type="xsd:boolean" default="true"/>
            <!--
               True to use Unicode string bind parameters, which are required with Unicode databases.
            -->
            <xsd:attribute name="host" type="xsd:string" use="required"/>
            <!--
               Database server host name.
            -->
            <xsd:attribute name="port" type="xsd:unsignedShort"/>
            <!--
               Database server port number (optional).
            -->
            <xsd:attribute name="instance" type="xsd:string"/>
            <!--
               Database server instance name (optional).
            -->
            <xsd:attribute name="database" type="xsd:string" use="required"/>
            <!--
               Database name.
            -->
            <xsd:attribute name="user" type="xsd:string"/>
            <!--
               Database user name.
            -->
            <xsd:attribute name="password" type="password"/>
            <!--
               Database user password.
            -->
            <xsd:attribute name="path" type="xsd:string"/>
            <!--
               Specifies a comma-delimited JDBC driver JAR file list.
            -->
            <xsd:attribute name="minPoolSize" type="nonNegativeInt" default="3"/>
            <!--
               Minimum database connection pool size per server.
               @category Performance
            -->
            <xsd:attribute name="maxPoolSize" type="positiveInt" default="33"/>
            <!--
               Maximum database connection pool size per server.
               @category Performance
            -->
            <xsd:attribute name="statementCacheSize" type="positiveInt" default="1000"/>
            <!--
               The prepared SQL statement cache size.
               @category Performance
            -->
            <xsd:attribute name="queryTimeout" type="nonNegativeInt" default="30"/>
            <!--
               The query timeout in seconds (0 for unlimited).
               @category Performance
            -->
            <xsd:attribute name="warningTimeout" type="nonNegativeLong" default="500"/>
            <!--
               The long-running query warning timeout in milliseconds (0 for unlimited). Overridable by the nexj.dataSourceConnection.<name>.warningTimeout system property.
               @category Performance
            -->
            <xsd:attribute name="driver" type="qualJavaName"/>
            <!--
               Overrides the default JDBC XA data source Java class name.
               @category Expert
            -->
            <xsd:attribute name="literal" type="xsd:boolean" default="false"/>
            <!--
               True to disable bind parameters and use literal binds in all SQL select queries.
               @category Expert
            -->
            <xsd:attribute name="pageSize" type="nonNegativeInt"/>
            <!--
               The database page size, in bytes. Zero or unspecified to use the persistence adapter default page size.
               @category Allocation
            -->
            <xsd:attribute name="indexspace" type="dbObjName"/>
            <!--
               Default index tablespace or file group name. Use "default" for the database default.
               @category Allocation
            -->
            <xsd:attribute name="longspace" type="dbObjName"/>
            <!--
               Default long column tablespace or file group name. Use "default" for the database default.
               @category Allocation
            -->
            <xsd:attribute name="tablespace" type="dbObjName"/>
            <!--
               Default tablespace or file group name. Use "default" for the database default.
               @category Allocation
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="FileStorageConnection">
      <xsd:complexContent>
         <xsd:extension base="DataSourceConnection">
            <xsd:sequence>
               <xsd:element name="Fragments" minOccurs="0" maxOccurs="1">
               <!--
                  @context FileStorage
               -->
                  <xsd:complexType>
                     <xsd:sequence>
                        <xsd:element name="Fragment" minOccurs="0" maxOccurs="unbounded">
                        <!--
                          @context FileStorage
                       -->
                           <xsd:complexType>
                              <xsd:attribute name="name" type="fragmentName" use="required"/>
                              <!--
                                 Fragment name.
                              -->
                              <xsd:attribute name="dataDirectory" type="xsd:string" use="required"/>
                              <!--
                                 The root of the directory tree used for storing the data files. When clustered, should be a shared directory.
                              -->
                              <xsd:attribute name="temporaryDirectory" type="xsd:string" use="required"/>
                              <!--
                                 The temporary directory used for preparing data files for persistence. When clustered, should be a shared directory.
                              -->
                              <xsd:attribute name="journalDirectory" type="xsd:string"/>
                              <!--
                                 The directory in which to store the transactional journal for the adapter.
                                 @category Expert
                              -->
                              <xsd:attribute name="subdirLevels" type="nonNegativeInt"/>
                              <!--
                                 The maximum number of levels of subdirectories to create inside the data directory.
                              -->
                              <xsd:attribute name="subdirNameLength" type="positiveInt"/>
                              <!--
                                 The number of characters in the names of the subdirectories created inside the data directory.
                              -->
                              <xsd:attribute name="maxPoolSize" type="positiveInt"/>
                              <!--
                                 The maximum connection pool size.
                              -->
                           </xsd:complexType>
                        </xsd:element>
                     </xsd:sequence>
                  </xsd:complexType>
               </xsd:element>
            </xsd:sequence>
            <xsd:attribute name="dataDirectory" type="xsd:string" use="required"/>
            <!--
               The root of the directory tree used for storing the data files. When clustered, should be a shared directory.
            -->
            <xsd:attribute name="temporaryDirectory" type="xsd:string" use="required"/>
            <!--
               The temporary directory used for preparing data files for persistence. When clustered, should be a shared directory.
            -->
            <xsd:attribute name="journalDirectory" type="xsd:string"/>
            <!--
               The directory in which to store the transactional journal for the adapter.
               @category Expert
            -->
            <xsd:attribute name="subdirLevels" type="nonNegativeInt"/>
            <!--
               The maximum number of levels of subdirectories to create inside the data directory.
            -->
            <xsd:attribute name="subdirNameLength" type="positiveInt"/>
            <!--
               The number of characters in the names of the subdirectories created inside the data directory.
            -->
            <xsd:attribute name="maxPoolSize" type="positiveInt" default="33"/>
            <!--
               The maximum connection pool size.
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="ServiceDataSourceConnection">
      <xsd:complexContent>
         <xsd:extension base="DataSourceConnection">
            <xsd:sequence>
               <xsd:element name="Properties" type="CustomProperties" minOccurs="0" maxOccurs="1"/>
               <!--
                  @context Connection
               -->
               <xsd:element name="Fragments" minOccurs="0" maxOccurs="1">
               <!--
                  @context ServiceDataSourceConnection
               -->
                  <xsd:complexType>
                     <xsd:sequence>
                        <xsd:element name="Fragment" minOccurs="0" maxOccurs="unbounded">
                        <!--
                           @context ServiceDataSourceConnection
                        -->
                           <xsd:complexType>
                              <xsd:sequence>
                                 <xsd:element name="Properties" type="CustomProperties" minOccurs="0" maxOccurs="1"/>
                                 <!--
                                    @context Connection
                                 -->
                              </xsd:sequence>
                              <xsd:attribute name="name" type="fragmentName" use="required"/>
                              <!--
                                 Fragment name.
                              -->
                              <xsd:attribute name="warningTimeout" type="nonNegativeLong" default="0"/>
                              <!--
                                 The long-running query warning timeout in milliseconds (0 for unlimited). Overridable by the nexj.dataSourceConnection.<name>.warningTimeout system property.
                                 @category Performance
                              -->
                           </xsd:complexType>
                        </xsd:element>
                     </xsd:sequence>
                  </xsd:complexType>
               </xsd:element>
            </xsd:sequence>
            <xsd:attribute name="warningTimeout" type="nonNegativeLong" default="0"/>
            <!--
               The long-running query warning timeout in milliseconds (0 for unlimited). Overridable by the nexj.dataSourceConnection.<name>.warningTimeout system property.
               @category Performance
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="MessageQueueConnection">
      <xsd:complexContent>
         <xsd:extension base="ChannelConnection">
            <xsd:sequence>
               <xsd:element name="FactoryProperties" type="CustomProperties" minOccurs="0" maxOccurs="1"/>
               <!--
                  The connection factory JNDI or bean properties.
                  @category Expert
               -->
               <xsd:element name="DestinationProperties" type="CustomProperties" minOccurs="0" maxOccurs="1"/>
               <!--
                  The destination JNDI or bean properties.
                  @category Expert
               -->
            </xsd:sequence>
            <xsd:attribute name="alias" type="alias"/>
            <!--
               Alias for JNDI lookup. Overrides the channel setting.
            -->
            <xsd:attribute name="subscription" type="xsd:string"/>
            <!--
               Subscription name for durable broadcast (topic) subscriptions. Overrides the channel setting.
            -->
            <xsd:attribute name="clientId" type="xsd:string"/>
            <!--
               Client identifier for durable broadcast (topic) subscriptions. Overrides the channel setting.
            -->
            <xsd:attribute name="maxSenders" type="nonNegativeInt"/>
            <!--
               Maximum queue sender connection pool size per server. Overrides the channel setting.
            -->
            <xsd:attribute name="maxReceivers" type="nonNegativeInt"/>
            <!--
               Maximum queue receiver thread pool size per server. Overrides the channel setting.
            -->
            <xsd:attribute name="errorCount" type="nonNegativeInt"/>
            <!--
               Maximum count of attempts at transacted processing of a message before forwarding
               it to the error queue (0 for unlimited). Overrides the channel setting.
            -->
            <xsd:attribute name="user" type="xsd:string"/>
            <!--
               JMS queue user.
               @category Security
            -->
            <xsd:attribute name="password" type="password"/>
            <!--
               JMS queue password.
               @category Security
            -->
            <xsd:attribute name="factory" type="xsd:string"/>
            <!--
               The connection factory JNDI or bean name (class:<name>).
               @category Expert
            -->
            <xsd:attribute name="destination" type="xsd:string"/>
            <!--
               The destination JNDI or bean name (class:<name>).
               @category Expert
            -->
            <xsd:attribute name="transactionTimeout" type="nonNegativeInt"/>
            <!--
               The timeout (in seconds) for transactions started on the J2EE component. Applies only to incoming transactional channels.
               @detail
               Set to 0 to use server default transaction timeout. Overrides the timeout setting on the Channel.
               @category Receiver
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="MailConnection">
      <xsd:complexContent>
         <xsd:extension base="ChannelConnection">
            <xsd:sequence>
               <xsd:element name="Properties" type="CustomProperties" minOccurs="0" maxOccurs="1"/>
               <!--
                  @context Mail Connection
               -->
            </xsd:sequence>
            <xsd:attribute name="alias" type="alias"/>
            <!--
               Alias for JNDI lookup. Overrides the channel setting.
            -->
            <xsd:attribute name="user" type="xsd:string"/>
            <!--
               Mail server user.
               @category Security
            -->
            <xsd:attribute name="password" type="password"/>
            <!--
               Mail server password.
               @category Security
            -->
            <xsd:attribute name="from" type="xsd:string"/>
            <!--
               Default sender e-mail address (From:).
            -->
            <xsd:attribute name="inHost" type="xsd:string"/>
            <!--
               Mail server host for incoming messages.
            -->
            <xsd:attribute name="inEncryption" default="SSL">
               <!--
                  Type of channel encryption to use for incoming data channel.
                  @category Security
               -->
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:enumeration value="none"/>
                     <!--
                        No channel encryption used for incoming data channel.
                     -->
                     <xsd:enumeration value="SSL"/>
                     <!--
                        SSL channel encryption used for incoming data channel.
                     -->
                     <xsd:enumeration value="TLS"/>
                     <!--
                        TLS channel encryption used for incoming data channel.
                     -->
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
            <xsd:attribute name="inPort" type="xsd:unsignedShort"/>
            <!--
               Mail server port for incoming messages.
            -->
            <xsd:attribute name="inProtocol" type="xsd:string" default="pop3"/>
            <!--
               Protocol for incoming messages (pop3, imap).
            -->
            <xsd:attribute name="inFolder" type="xsd:string" default="INBOX"/>
            <!--
               Mail server incoming message folder.
            -->
            <xsd:attribute name="outAuthentication" default="none">
               <!--
                  Type of authentication to perform before sending mail over SMTP.
                  @category Security
               -->
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:enumeration value="none"/>
                     <!--
                        When sending mail no authentication performed with SMTP server.
                     -->
                     <xsd:enumeration value="basic"/>
                     <!--
                        When sending mail use user/password authentication with SMTP server.
                     -->
                     <xsd:enumeration value="receive"/>
                     <!--
                        When sending mail first open a connection to the incoming store, before contacting SMTP server.
                     -->
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
            <xsd:attribute name="outHost" type="xsd:string"/>
            <!--
               Mail server host for outgoing messages.
            -->
            <xsd:attribute name="outEncryption" default="none">
               <!--
                  Type of channel encryption to use for outgoing data channel.
                  @category Security
               -->
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:enumeration value="none"/>
                     <!--
                        No channel encryption used for outgoing data channel.
                     -->
                     <xsd:enumeration value="SSL"/>
                     <!--
                        SSL channel encryption used for outgoing data channel.
                     -->
                     <xsd:enumeration value="TLS"/>
                     <!--
                        TLS channel encryption used for outgoing data channel.
                     -->
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
            <xsd:attribute name="outPort" type="xsd:unsignedShort"/>
            <!--
               Mail server port for outgoing messages.
            -->
            <xsd:attribute name="outProtocol" type="xsd:string" default="smtp"/>
            <!--
               Protocol for outgoing messages (smtp).
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="HTTPConnection">
      <xsd:complexContent>
         <xsd:extension base="ChannelConnection">
            <xsd:attribute name="url" type="xsd:string"/>
            <!--
               Default HTTP request URL. Overrides the channel setting.
            -->
            <xsd:attribute name="maxSize" type="nonNegativeInt" default="0"/>
            <!--
               Maximum HTTP request size in bytes (0 is unlimited).
            -->
            <xsd:attribute name="secure" type="xsd:boolean"/>
            <!--
               True to require HTTPS communication in the receiver. Defaults to secureTransport in the server configuration.
               @category Security
            -->
            <xsd:attribute name="authentication" default="basic">
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:enumeration value="none"/>
                     <!--
                        No authentication. Log in anonymously.

                        @detail
                        If selected, inbound connections are accessed through the anonymous context root.
                        If selected and if authorization is required by the remote system, then outbound connections generate an error.

                        @see
                        Server.httpAnonymousURL
                     -->
                     <xsd:enumeration value="basic"/>
                     <!--
                        Authenticate using a basic username and password. (default)
                     -->
                     <xsd:enumeration value="proactive"/>
                     <!--
                        Authenticate using a basic username and password that can be submitted as part of the initial request to the server.
                        This option allows you to authenticate without waiting to be prompted for authentication information.
                        When using this mode, you must ensure that the server host is trusted so that authentication information is not revealed inadvertently.
                     -->
                     <xsd:enumeration value="credential"/>
                     <!--
                        Authenticate using an SPNEGO username and password.
                     -->
                     <xsd:enumeration value="server"/>
                     <!--
                        Authenticate using SPNEGO silent sign-on and the server process account.
                     -->
                     <xsd:enumeration value="certificate"/>
                     <!--
                        Authenticate using an X.509 certificate.
                     -->
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
            <!--
               Authentication mode: none - anonymous, basic - basic user/password, credential - SPNEGO user/password, server - silent SPNEGO w/server process account, certificate - X.509 certificate.
               @category Security
            -->
            <xsd:attribute name="user" type="xsd:string"/>
            <!--
               User name for the HTTP sender.
               @category Security
            -->
            <xsd:attribute name="password" type="password"/>
            <!--
               Password for the HTTP sender. If using a certificate, this is the certificate password.
               @category Security
            -->
            <xsd:attribute name="readTimeout" type="nonNegativeInt"/>
            <!--
               Timeout in milliseconds for outbound HTTP requests, 0 for infinite timeout. Defaults to the channel readTimeout.
               @category Behavior
            -->
            <xsd:attribute name="connectionTimeout" type="nonNegativeInt"/>
            <!--
               Timeout in milliseconds for establishing HTTP connections, 0 for infinite timeout. Defaults to the channel connectionTimeout.
               @category Behavior
            -->
            <xsd:attribute name="certificate" type="xsd:string"/>
            <!--
               The HTTP sender's certificate and private key, for logging in to the remote system. Certificate must be base64-encoded PKCS #12 representation.
               @category Security

               @detail
               Used for outgoing channels only. For incoming channels, the "certificate" parameter is unused. The
               web server always presents the same certificate to the remote system; this is configured in the application
               server configuration files. The "trust" parameter should be the remote system's certificate or its signer
               certificate.

               @see Trust property
            -->
            <xsd:attribute name="trust" type="xsd:string"/>
            <!--
               The X.509 certificate, or signer's certificate thereof, for the remote system. Unspecified to trust certificates in default trust store.
               @category Security

               @detail
               The CN from the certificate presented by the remote system is used as the user principal for which the invocation context
               will be created. This allows support of multiple external systems authenticating to an HTTP channel, mapped
               to different users based on the certificates they present.  http://en.wikipedia.org/wiki/X.509
            -->
            <xsd:attribute name="proxyHost" type="xsd:string"/>
            <!--
               The proxy server to use for the HTTP sender.
            -->
            <xsd:attribute name="proxyPort" type="xsd:unsignedShort"/>
            <!--
               The proxy server port to use for the HTTP sender. Must be specified if using proxy other than
               JRE default proxy.
            -->
            <xsd:attribute name="proxyUser" type="xsd:string"/>
            <!--
               User name for the HTTP sender when connecting to a proxy server.
               @category Security
            -->
            <xsd:attribute name="proxyPassword" type="password"/>
            <!--
               Password for the HTTP sender when connecting to a proxy server.
               @category Security
            -->
            <xsd:attribute name="proxyAuthentication" default="basic">
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:enumeration value="basic"/>
                     <!--
                        Authenticate using a basic username and password. (default)
                     -->
                     <xsd:enumeration value="proactive"/>
                     <!--
                        Authenticate using a basic username and password that can be submitted as part of the initial request to the proxy.
                        This option allows you to authenticate without waiting to be prompted for authentication information.
                        When using this mode, you must ensure that the proxy host is trusted so that authentication information is not revealed inadvertently.
                     -->
                     <xsd:enumeration value="credential"/>
                     <!--
                        Authenticate using an SPNEGO username and password.
                     -->
                     <xsd:enumeration value="server"/>
                     <!--
                        Authenticate using SPNEGO silent sign-on and the server process account.
                     -->
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
            <!--
               Proxy authentication mode: basic - basic user/password, credential - SPNEGO user/password, server - silent SPNEGO w/server process account.
               @category Security
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="UDPConnection">
      <xsd:complexContent>
         <xsd:extension base="ChannelConnection">
            <xsd:attribute name="encoding" type="xsd:string"/>
            <!--
               Character encoding for string messages. Overrides the channel setting.
            -->
            <xsd:attribute name="host" type="xsd:string"/>
            <!--
               Remote UDP host or multicast group.
            -->
            <xsd:attribute name="port" type="xsd:unsignedShort"/>
            <!--
               Remote UDP port. Overrides the channel setting.
            -->
            <xsd:attribute name="localHost" type="xsd:string"/>
            <!--
               Local UDP host for binding (* or empty binds to all interfaces).
            -->
            <xsd:attribute name="localPort" type="xsd:unsignedShort"/>
            <!--
               Local UDP port (0 or empty for a random port). Overrides the channel setting.
            -->
            <xsd:attribute name="group" type="xsd:string"/>
            <!--
               Multicast group IP address. Overrides the channel setting.
            -->
            <xsd:attribute name="ttl" type="xsd:unsignedByte"/>
            <!--
               Packet time-to-live in hops (0..255). Overrides the channel setting.
            -->
            <xsd:attribute name="maxSenders" type="nonNegativeInt"/>
            <!--
               Maximum sender connection pool size per server. Overrides the channel setting.
            -->
            <xsd:attribute name="maxReceivers" type="nonNegativeInt"/>
            <!--
               Maximum receiver thread pool size per server. Overrides the channel setting.
            -->
            <xsd:attribute name="tos" type="xsd:unsignedByte"/>
            <!--
               RFC 1349 type-of-service value (sum of lowCost=2, reliability=4, throughput=8, lowDelay=16).
               @category Sender
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>
   
   <xsd:complexType name="TCPConnection">
   <!--
      A regular (non-secure) TCP connection should not specify the "certificate", "password",
      "trust", "authentication", or "mapper" properties.

      A secure TCP connection can have several different configurations, described below.

      Server-mode, no authentication:
         In this case, the "certificate" property must be specified. It will be a PKCS #12 key store
         that contains the server's private key and the certificate chain corresponding to its
         public key, encoded as a base64 string. The certificate chain and public key are presented
         to any clients attempting to establish a secure TCP connection. 
         Potential clients must trust this server's certificate chain. This could be accomplished
         in several ways:
            1) The server's certificate could be self-signed, and the client could add it to the default
            cacerts file for the JRE.
            2) The server's certificate could be signed by a well-known certificate authority such as
            VeriSign or Thawte. This works because the well-known certificates are automatically included
            in the cacerts file distributed with Java and hence a trusted certificate chain will exist.
            3) The client could specify a trusted certificate at runtime using the Java API or in the case
            of using the NexJ framework as the client, the "trust" property could be set.

      Server-mode with client authentication:
         In this case, the "certificate" property also must be specified (see above).
         For client authentication, the "trust" property should also be specified. It will be a 
         X.509 certificate encoded as a base64 string. It can be used in several ways:
            1) To trust only one possible client, simply set that client's certificate as the 
            "trust" property. In this situation, clients with any other certificate will be refused.
               If the client's certificate is not self-signed, the signer must also be trusted (i.e.
               found in the system's default trust store).
            2) To trust a group of clients, sign all of the client's certificates with one common certificate
            (the signing certificate) and set the "trust" property on the server to be that signing
            certificate.
            3) Trusted certificates could be added to the system's default trust store.
         By specifying a mapping component, clients can be logged in as different users based on their
         certificate. See the "mapper" property. If unspecified, the "defaultUser" property is used.

      Client-mode, no authentication:
         In this case, the "certificate" property is not used. However, when connecting to a remote system,
         the certificate chain the server presents must be trusted. This could be accomplished in several ways:
            1) The server's certificate could be self-signed, and the client could add it to the default
            cacerts file for the JRE.
            2) The server's certificate could be signed by a well-known certificate authority such as
            VeriSign or Thawte. This works because the well-known certificates are automatically included
            in the cacerts file distributed with Java and hence a trusted certificate chain will exist.
            3) The client could specify a trusted certificate at runtime by setting the "trust" property
            to the remote systems's certificate, or to the remote system's signer certificate. Either way,
            the entire certificate chain must be trusted (i.e. the remainder of the chain must be in cacerts).

      Client-mode with client authentication:
         In this case, the "trust" property may need to be specified (see above). However, for client
         authentication, the "certificate" property must be specified. This will contain the certificate
         chain presented to the server. If the server rejects the client's certificate chain, then a 
         secure TCP connection will not be established.

      Java 7 is needed on Windows for an IPv6 receiver.
   -->
      <xsd:complexContent>
         <xsd:extension base="ChannelConnection">
            <xsd:attribute name="encoding" type="xsd:string"/>
            <!--
               Character encoding for string messages. Overrides the channel setting.
            -->
            <xsd:attribute name="host" type="xsd:string"/>
            <!--
               Remote TCP host.
            -->
            <xsd:attribute name="port" type="positiveUnsignedShort"/>
            <!--
               Remote TCP port. Overrides the channel setting.
            -->
            <xsd:attribute name="localHost" type="xsd:string"/>
            <!--
               Local TCP host for binding (* or empty binds to all interfaces).
            -->
            <xsd:attribute name="localPort" type="xsd:unsignedShort"/>
            <!--
               Local TCP port (0 or empty for a random port). Overrides the channel setting.
            -->
            <xsd:attribute name="backlog" type="nonNegativeInt"/>
            <!--
               The server backlog size (the maximum number of pending connections
               that are waiting to be accepted by the listener).
               If the value is 0, then the system default value will be used. 
               @category Receiver
            -->
            <xsd:attribute name="readTimeout" type="nonNegativeInt"/>
            <!--
               The message read timeout in milliseconds.
               This is the maximum time the channel will block while in the
               process of receiving a message. If a timeout occurs, a
               nexj.core.rpc.tcp.ra.TCPTimeoutException will be raised.
               A value of zero indicates an infinite timeout.
               @category Receiver
            -->
            <xsd:attribute name="secure" type="xsd:boolean"/>
            <!--
               True if this channel should use SSL/TLS.
               
               @category Security
            -->
            <xsd:attribute name="authentication">
               <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
                     <xsd:enumeration value="none"/>
                     <xsd:enumeration value="supported"/>
                     <xsd:enumeration value="required"/>
                  </xsd:restriction>
               </xsd:simpleType>
            </xsd:attribute>
            <!--
               Determines if SSL client authentication is supported, required, or not used at all.
               
               Three possible values: "none", "supported", "required".
               none: Client authentication is not used.
               supported: The server will request authentication from the client, but it is not required.
               required: The server will require client authentication.
               
               This attribute is only applicable when SSL is enabled.
               The set of authenticated clients is determined by the "trust" property 
               or, if "trust" is unspecified, the JRE's default trust store.
               
               @category Receiver
               @see Trust property
            -->
            <xsd:attribute name="password" type="password"/>
            <!--
               The certificate password.
               
               @category Security
               @see Certificate property
            -->
            <xsd:attribute name="certificate" type="xsd:string"/>
            <!--
               The TCP connection's certificate and private key in base64-encoded PKCS #12 representation.

               Unnecessary for outgoing connections that do not require client certificate authentication.
               As a server, this certificate is presented to remote clients.
               As a client, this certificate is used for authentication to the remote server.

               This property contains the entire PCKS #12 key store as a base64-encoded string.

               @category Security
               @see Trust property
            -->
            <xsd:attribute name="trust" type="xsd:string"/>
            <!--
               A trusted X.509 certificate, in base64 encoding. Unspecified to trust certificates in the default trust store.

               If the mapper component attribute is set, a mapping from the client's certificate chain to 
               the user principal will be performed by that component.
               This allows us to support multiple external systems "logging in" to a TCP channel, mapped
               to different users based on the certificates they present.
               
               This property contains the contents of an X.509, base64-encoded certificate beginning with
               the standard "BEGIN CERTIFICATE" and "END CERTIFICATE" header/footer. It must also contain the
               standard line breaks.
               
               @category Security
               @see mapper property
            -->
            <xsd:attribute name="mapper" type="xsd:string"/>
            <!--
               The name of the associated user mapping component.
               
               This component will perform a mapping from the client's certificate chain to the user principal
               for which the invocation context will be created.
               It must implement the nexj.core.util.auth.CertificatePrincipalMapper interface.
               
               @category Security
            -->
            <xsd:attribute name="idleTimeout" type="nonNegativeInt"/>
            <!--
               The number of minutes this channel will be allowed to remain inactive
               before it is forcibly closed.
               A value of zero indicates an infinite limit.
               
               This timeout only applies to inactivity between messages. For inactivity
               while receiving a message, refer to the "readTimeout" property.
               
               @category Receiver
            -->
            <xsd:attribute name="keepAlive" type="xsd:boolean"/>
            <!--
               True if the TCP keep-alive property should be set on the underlying socket.
               
               @category Receiver
            -->
            <xsd:attribute name="connectionTimeout" type="nonNegativeInt"/>
            <!--
               Timeout in milliseconds for establishing TCP connections, 0 for infinite timeout.
               
               @category Sender
            -->
            <xsd:attribute name="noDelay" type="xsd:boolean"/>
            <!--
               True if the TCP no-delay property should be set on the underlying socket.
            -->
            <xsd:attribute name="maxSenders" type="nonNegativeInt"/>
            <!--
               Maximum sender connection pool size per server. Overrides the channel setting.
            -->
            <xsd:attribute name="maxReceivers" type="nonNegativeInt"/>
            <!--
               Maximum receiver thread pool size per server. Overrides the channel setting.
            -->
            <xsd:attribute name="senderBufferSize" type="nonNegativeInt"/>
            <!--
               The SO_SNDBUF option for the underlying socket, 0 for system default.
            -->
            <xsd:attribute name="receiverBufferSize" type="nonNegativeInt"/>
            <!--
               The SO_RCVBUF option for the underlying socket, 0 for system default.
            -->
            <xsd:attribute name="tos" type="xsd:unsignedByte"/>
            <!--
               RFC 1349 type-of-service value (sum of lowCost=2, reliability=4, throughput=8, lowDelay=16).
               @category Sender
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="FileConnection">
      <xsd:complexContent>
         <xsd:extension base="ChannelConnection">
            <xsd:attribute name="incomingDirectory" type="xsd:string"/>
            <!--
               The full path to the directory to scan for incoming message files. When clustered, should be a shared directory.
               @category Receiver
            -->
            <xsd:attribute name="levels" type="nonNegativeInt" default="0"/>
            <!--
               The number of subdirectory levels to which the incoming directory should be scanned. Zero to scan only the incoming directory.
               @category Receiver
            -->
            <xsd:attribute name="processedDirectory" type="xsd:string"/>
            <!--
               The full path to the directory for processed incoming messages; blank to delete message when processed. When clustered, should be a shared directory.
               @category Receiver
            -->
            <xsd:attribute name="outgoingDirectory" type="xsd:string"/>
            <!--
               The full path to the directory in which to place outgoing message files. When clustered, should be a shared directory.
               @category Sender
            -->
            <xsd:attribute name="temporaryDirectory" type="xsd:string"/>
            <!--
               The full path to the temporary directory used for preparing outgoing messages. When clustered, should be a shared directory.
               @detail
               For best reliability and efficiency, should be on the same filesystem as "outgoingDirectory".
               Defaults to a directory called "tmp" inside "outgoing".
               @category Sender
            -->
            <xsd:attribute name="journalDirectory" type="xsd:string"/>
            <!--
               The full path to the directory for the transactional journals for this channel.
               @category Expert
            -->
            <xsd:attribute name="interval" type="nonNegativeLong" default="30000"/>
            <!--
               The input scanning interval (in ms) between successive scans of the incoming directory.
               @category Receiver
            -->
            <xsd:attribute name="age" type="nonNegativeLong" default="15000"/>
            <!--
               The minimum age (in ms) of an incoming message file for it to be detected by the channel.
               @category Receiver
            -->
            <xsd:attribute name="pattern" type="xsd:string" default="*"/>
            <!--
               The like-pattern used to select incoming message files for processing.
               @category Receiver
            -->
            <xsd:attribute name="processedName" type="xsd:string" default="${orig}_${ts}"/>
            <!--
               The template to use for generating a new name for incoming files after they have been processed. (Timestamp: ${ts}, Sequence number: ${seq}, Original path: ${orig}, GUID: ${guid})

               @detail
               ${ts} - Timestamp in milliseconds
               ${seq} - Sequence number
               ${guid} - GUID
               ${orig} - The original file path, relative to the incoming directory
               ${origName} - The original file name
               @category Receiver
            -->
            <xsd:attribute name="outgoingName" type="xsd:string" default="${ts}_${seq}"/>
            <!--
               The template to use for automatically generating outgoing message file names. (Timestamp: ${ts}, Sequence number: ${seq}, GUID: ${guid})

               @detail
               ${ts} - Timestamp in milliseconds
               ${seq} - Sequence number
               ${guid} - GUID
               @category Sender
            -->
            <xsd:attribute name="transactionTimeout" type="nonNegativeInt"/>
            <!--
               The timeout (in seconds) for transactions started on the J2EE component. Applies only to incoming transactional channels.
               @detail
               Set to 0 to use server default transaction timeout. Overrides the timeout setting on the Channel.
               @category Receiver
            -->
            <xsd:attribute name="maxSenders" type="nonNegativeInt"/>
            <!--
               Maximum file sender connection pool size per server. Overrides the channel setting.
               @category Sender
            -->
            <xsd:attribute name="maxReceivers" type="nonNegativeInt"/>
            <!--
               Maximum file receiver thread pool size per server. Overrides the channel setting.
               @category Receiver
            -->
         </xsd:extension>
      </xsd:complexContent>
   </xsd:complexType>

   <xsd:complexType name="SOAConnections">
      <xsd:sequence>
         <xsd:element name="SOAConnection" minOccurs="0" maxOccurs="unbounded">
            <xsd:complexType>
               <xsd:sequence>
                  <xsd:element name="Properties" type="CustomProperties" minOccurs="0" maxOccurs="1"/>
                  <!--
                     @context SOAConnection
                  -->
               </xsd:sequence>
               <xsd:attribute name="service" type="xsd:string" use="required"/>
               <!--
                  The service connected by this connection.
               -->
               <xsd:attribute name="instance" type="xsd:string"/>
               <!--
                  The name of the service instance to connect; unspecified for the default instance.
               -->
               <xsd:attribute name="binding" type="xsd:string"/>
               <!--
                  The binding for connecting to the service. Overrides the binding from the registry.
                  @detail
                  The bindings supported by default are "trpc" and "local".
               -->
               <xsd:attribute name="address" type="xsd:string"/>
               <!--
                  The address for connecting to the service. Overrides the address from the registry.
                  The address is a string in binding-specific format. If address is specified, then binding
                  must also be specified.
               -->
               <xsd:attribute name="auth">
                  <xsd:simpleType>
                     <xsd:restriction base="xsd:string">
                        <xsd:enumeration value="basic"/>
                        <xsd:enumeration value="perimeter"/>
                     </xsd:restriction>
                  </xsd:simpleType>
               </xsd:attribute>
               <!--
                  The authentication mode for connecting to the service. Overrides the authentication mode from the
                  registry.
               -->
               <xsd:attribute name="user" type="xsd:string"/>
               <!--
                  The user to log in to the service, if using an authentication mode that requires a user name.
                  Overrides the user provided by the registry, if any.
               -->
               <xsd:attribute name="password" type="password"/>
               <!--
                  The password to log in to the serivce, if using an authentication mode that requires a password.
                  Overrides the password provided by the registry, if any.
               -->
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:complexType>
</xsd:schema>

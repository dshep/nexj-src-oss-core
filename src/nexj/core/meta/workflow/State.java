// Copyright 2010 NexJ Systems Inc. This software is licensed under the terms of the Eclipse Public License 1.0
package nexj.core.meta.workflow;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;

import nexj.core.rpc.InstanceFactory;
import nexj.core.rpc.RPCUtil;
import nexj.core.rpc.TransferObject;
import nexj.core.rpc.text.TextMarshaller;
import nexj.core.rpc.text.TextUnmarshaller;
import nexj.core.runtime.Instance;
import nexj.core.runtime.InstanceList;
import nexj.core.runtime.InvocationContext;
import nexj.core.runtime.SerializablePropertyMap;
import nexj.core.scripting.PCodeFunction;
import nexj.core.scripting.Pair;
import nexj.core.util.Binary;
import nexj.core.util.EmptyIterator;
import nexj.core.util.HashTab;
import nexj.core.util.Logger;
import nexj.core.util.Lookup;
import nexj.core.util.PropertyIterator;
import nexj.core.util.UncheckedException;

/**
 * Flow state storage.
 */
public final class State implements SerializablePropertyMap
{
   // constants

   /**
    * Comparator for sorting steps by ordinal number.
    */
   public final static Comparator ELEMENT_COMPARATOR = new Comparator()
   {
      public int compare(Object o1, Object o2)
      {
         return ((Step)o1).getOrdinal() - ((Step)o2).getOrdinal();
      }
   };

   // attributes

   /**
    * Flow step count.
    */
   protected int m_nStepCount;

   /**
    * Marked Activity count.
    */
   protected int m_nMarkedActivityCount;

   /**
    * Variable offset.
    */
   protected int m_nVarOfs;

   /**
    * The dirty flag.
    */
   protected boolean m_bDirty;

   // associations

   /**
    * The flow.
    */
   protected Flow m_flow;

   /**
    * The last run step.
    */
   protected Step m_lastStep;

   /**
    * Flow step array.
    */
   protected Step[] m_stepArray = new Step[4];

   /**
    * Marked activity array.
    */
   protected Activity[] m_markedActivityArray = new Activity[4];

   /**
    * New activity array, used in computations by computeCleanupActivityCollection().
    */
   protected Activity[] m_newActivityArray = new Activity[4];

   /**
    * Old activity array, used in computations by computeCleanupActivityCollection().
    */
   protected Activity[] m_oldActivityArray = new Activity[4];

   /**
    * Token value map: Object[String].
    */
   protected Lookup m_tokenMap;

   /**
    * The variable value array, used also as a closure frame.
    * The 0-th entry is reserved as a frame pointer.
    */
   protected Object[] m_variableArray;

   /**
    * Cleanup step list.
    */
   protected List m_cleanupStepList;

   /**
    * Transient list of activities to clean up before proceeding to next step.
    */
   protected List m_cleanupActivityList = new ArrayList(4);

   /**
    * A map of the Fork name to the associated ThreadInfo object.
    * Used for parallel execution.
    */
   protected Lookup m_threadInfoLookup = new HashTab();  // ThreadInfo[String]

   /**
    * The class logger.
    */
   protected final static Logger s_logger = Logger.getLogger(State.class);

   // constructors

   /**
    * Constructs an uninitialized state.
    * @param flow The flow, which state to construct.
    */
   protected State(Flow flow)
   {
      m_flow = flow;
      m_nVarOfs = flow.getReservedVarCount() + 1; // 1 for the frame offset
      m_variableArray = new Object[flow.getVariableCount() + m_nVarOfs];
   }

   /**
    * Constructs the state from a string and variable state.
    * @param flow The flow, which state to construct.
    * @param sState A string previously generated by toString().
    * @param sVariables A string previously generated by serializeVariables().
    */
   public State(Flow flow, String sState, String sVariables, InvocationContext context)
   {
      this(flow);
      fromString(sState);
      deserializeValues(sVariables, context);
      m_bDirty = false;
   }

   /**
    * Constructs an initial flow state.
    * @param flow The flow, which state to construct.
    * @param bFirst True to add the first element to the state.
    */
   public State(Flow flow, boolean bFirst)
   {
      this(flow);

      if (bFirst)
      {
         add(flow.getFirstStep());
      }
   }

   // operations

   /**
    * Gets the activities requiring clean up.
    *
    * @return The collection of activities to clean up.
    */
   public Collection getCleanupActivityCollection()
   {
      return m_cleanupActivityList;
   }

   /**
    * Marks the current set of activities for use by
    * computeCleanupActivityCollection().
    */
   public void markActivities()
   {
      m_cleanupActivityList.clear();

      if (m_markedActivityArray.length < m_nStepCount)
      {
         m_markedActivityArray = new Activity[m_nStepCount];
      }

      for (int i = 0; i < m_nStepCount; i++)
      {
         m_markedActivityArray[i] = m_stepArray[i].getActivity();
      }

      m_nMarkedActivityCount = m_nStepCount;
   }

   /**
    * Removes the duplicate (by reference) elements from the array,
    * returns the new size of the array.
    * @param array The array.
    * @param nSize The size of the array.
    * @return The new size of the array.
    */
   public static int removeDuplicates(Object[] array, int nSize)
   {
      int i = 0;

      while (i < nSize)
      {
         int j = i + 1;

         while (j < nSize)
         {
            if (array[i] == array[j])
            {
               System.arraycopy(array, j + 1, array, j, nSize - j - 1);
               nSize--;
            }
            else
            {
               j++;
            }
         }

         i++;
      }

      return nSize;
   }

   /**
    * Computes the cleanup activity collection by taking the difference
    * between the state when markActivities() was called and the current state.
    */
   public void computeCleanupActivityCollection()
   {
      int i = 0;
      int nSize = m_nStepCount;
      int nOldSize = m_nMarkedActivityCount;

      // Expand computation arrays, if necessary
      if (nSize > m_newActivityArray.length)
      {
         m_newActivityArray = new Activity[nSize];
      }

      if (nOldSize > m_oldActivityArray.length)
      {
         m_oldActivityArray = new Activity[nOldSize];
      }

      // Initialize computation arrays
      for (i = 0; i < nSize; i++)
      {
         m_newActivityArray[i] = m_stepArray[i].getActivity();
      }

      System.arraycopy(m_markedActivityArray, 0, m_oldActivityArray, 0, nOldSize);

      m_cleanupActivityList.clear();

      // Expand parents, adding only activities requiring cleanup
      while (nOldSize > 0)
      {
         i = 0;

         while (i < nOldSize)
         {
            if (m_oldActivityArray[i].isCleanupRequired())
            {
               if (!m_cleanupActivityList.contains(m_oldActivityArray[i]))
               {
                  m_cleanupActivityList.add(m_oldActivityArray[i]);
               }
            }

            m_oldActivityArray[i] = m_oldActivityArray[i].getParent();

            if (m_oldActivityArray[i] == null)
            {
               System.arraycopy(m_oldActivityArray, i + 1, m_oldActivityArray, i, nOldSize - i - 1);
               nOldSize--;
            }
            else
            {
               i++;
            }
         }

         // Remove duplicate activities
         nOldSize = removeDuplicates(m_oldActivityArray, nOldSize);
      }

      // Iterate newActArray and all its parents, removing cleanup-required activities from m_cleanupActivityList
      while (nSize > 0 && !m_cleanupActivityList.isEmpty())
      {
         i = 0;

         while (i < nSize)
         {
            if (m_newActivityArray[i].isCleanupRequired())
            {
               m_cleanupActivityList.remove(m_newActivityArray[i]);

               if (m_cleanupActivityList.isEmpty())
               {
                  break;
               }
            }

            m_newActivityArray[i] = m_newActivityArray[i].getParent();

            if (m_newActivityArray[i] == null)
            {
               System.arraycopy(m_newActivityArray, i + 1, m_newActivityArray, i, nSize - i - 1);
               nSize--;
            }
            else
            {
               i++;
            }
         }

         // Remove duplicate activities
         nSize = removeDuplicates(m_newActivityArray, nSize);
      }
   }

   /**
    * @return The flow.
    */
   public Flow getFlow()
   {
      return m_flow;
   }

   /**
    * Sets the dirty flag.
    * @param bDirty The dirty flag to set.
    */
   public void setDirty(boolean bDirty)
   {
      m_bDirty = bDirty;
   }

   /**
    * @return The dirty flag.
    */
   public boolean isDirty()
   {
      return m_bDirty;
   }

   /**
    * Sets an activity token value.
    * @param activity The activity.
    * @param value The token value.
    */
   public void setToken(Activity activity, Object value)
   {
      if (m_tokenMap == null)
      {
         m_tokenMap = new HashTab(4);
      }

      if (activity == null)
      {
         activity = m_flow;
      }

      m_tokenMap.put(activity.getTokenName(), value);
   }

   /**
    * Gets an activity token value.
    * @param activity The activity.
    * @return The token value.
    */
   public Object getToken(Activity activity)
   {
      if (m_tokenMap == null)
      {
         return null;
      }

      if (activity == null)
      {
         activity = m_flow;
      }

      return m_tokenMap.get(activity.getTokenName());
   }

   /**
    * Removes an activity token value.
    * @param activity The activity.
    * @return The removed value.
    */
   public Object removeToken(Activity activity)
   {
      if (m_tokenMap == null)
      {
         return null;
      }

      return m_tokenMap.remove(activity.getTokenName());
   }

   /**
    * Sets the value of a reserved variable.
    * @param nOrdinal The ordinal number of the reserved variable.
    * @param value The value to set.
    */
   public void setReservedValue(int nOrdinal, Object value)
   {
      m_variableArray[nOrdinal + 1] = value;
   }

   /**
    * Get the flow Instance (SysService/SysWorkflow instance).
    * @return The flow Instance.
    */
   public Instance getFlowInstance()
   {
      return (Instance)m_variableArray[1];
   }

   /**
    * Sets the value of a variable.
    * @param var The variable to set.
    * @param value The variable value.
    */
   public void setValue(Variable var, Object value)
   {
      m_variableArray[var.getOrdinal() + m_nVarOfs] = value;
      m_bDirty = true;
   }

   /**
    * Sets the value of a variable.
    * @param sName The variable name.
    * @param value The variable value.
    */
   public void setValue(String sName, Object value)
   {
      m_variableArray[m_flow.getVariable(sName).getOrdinal() + m_nVarOfs] = value;
      m_bDirty = true;
   }

   /**
    * Gets the value of a variable.
    * @param var The variable which value to get.
    * @return The variable value.
    */
   public Object getValue(Variable var)
   {
      return m_variableArray[var.getOrdinal() + m_nVarOfs];
   }

   /**
    * Gets the value of a variable by name.
    * @param sName The variable name.
    * @return The variable value.
    */
   public Object getValue(String sName)
   {
      return m_variableArray[m_flow.getVariable(sName).getOrdinal() + m_nVarOfs];
   }

   /**
    * @see nexj.core.util.PropertyMap#findValue(java.lang.String)
    */
   public Object findValue(String sName)
   {
      return findValue(sName, null);
   }

   /**
    * @see nexj.core.util.PropertyMap#findValue(java.lang.String, java.lang.Object)
    */
   public Object findValue(String sName, Object defaultValue)
   {
      Variable var = m_flow.findVariable(sName);

      if (var == null)
      {
         return defaultValue;
      }

      return m_variableArray[var.getOrdinal() + m_nVarOfs];
   }

   /**
    * @see nexj.core.util.PropertyMap#hasValue(java.lang.String)
    */
   public boolean hasValue(String sName)
   {
      return m_flow.findVariable(sName) != null;
   }

   /**
    * @see nexj.core.util.PropertyMap#getValueCount()
    */
   public int getValueCount()
   {
      return m_flow.getVariableCount();
   }

   /**
    * @see nexj.core.util.PropertyMap#getIterator()
    */
   public PropertyIterator getIterator()
   {
      return new PropertyIterator()
      {
         private Iterator m_itr = m_flow.getVariableIterator();
         private Variable m_var;

         public String getName()
         {
            return m_var.getName();
         }

         public Object getValue()
         {
            return State.this.getValue(m_var);
         }

         public void setValue(Object value)
         {
            State.this.setValue(m_var, value);
         }

         public void remove()
         {
            State.this.setValue(m_var, null);
         }

         public boolean hasNext()
         {
            return m_itr.hasNext();
         }

         public Object next()
         {
            return m_var = (Variable)m_itr.next();
         }
      };
   }

   /**
    * @see nexj.core.util.PropertyMap#getClassName()
    */
   public String getClassName()
   {
      return "state";
   }

   /**
    * Serializes values to a writer.
    * @param writer The writer.
    * @param context The context.
    * @return true if any values were serialized.
    */
   protected boolean serializeValues(Writer writer, InvocationContext context)
   {
      int nCount = m_flow.getVariableCount();
      TransferObject tobj = new TransferObject(nCount + ((m_tokenMap == null) ? 0 : m_tokenMap.size()));
      TransferObject instances = null;
      Lookup identityMap = null;

      for (int i = 0; i != nCount; ++i)
      {
         Variable var = m_flow.getVariable(i);
         Object value = getValue(var);

         if (value != null)
         {
            if (value instanceof Instance || value instanceof InstanceList)
            {
               if (identityMap == null)
               {
                  identityMap = new HashTab();
                  instances = new TransferObject();
                  tobj.setValue(":instances", instances);
               }

               instances.setValue(var.getName(), RPCUtil.transferState(value, null, identityMap, RPCUtil.TF_ALL));
            }
            else
            {
               tobj.setValue(var.getName(), value);
            }
         }
      }

      if (m_tokenMap != null)
      {
         for (Lookup.Iterator itr = m_tokenMap.iterator(); itr.hasNext();)
         {
            itr.next();
            tobj.setValue((String)itr.getKey(), itr.getValue());
         }
      }

      if (tobj.getValueCount() == 0)
      {
         return false;
      }

      try
      {
         new TextMarshaller(context).serialize(tobj, writer);
      }
      catch (IOException e)
      {
         throw new UncheckedException("err.rpc.valueSerialization", e);
      }

      return true;
   }

   /**
    * @see nexj.core.runtime.SerializablePropertyMap#serializeValuesToBinary(nexj.core.runtime.InvocationContext)
    */
   public Binary serializeValuesToBinary(InvocationContext context)
   {
      ByteArrayOutputStream bos = new ByteArrayOutputStream();

      try
      {
         Writer writer = new BufferedWriter(new OutputStreamWriter(bos, "UTF-8"));

         if (!serializeValues(writer, context))
         {
            return null;
         }

         writer.flush();
      }
      catch (IOException e)
      {
         throw new UncheckedException("err.rpc.valueSerialization", e);
      }

      return new Binary(bos.toByteArray());
   }

   /**
    * @see nexj.core.util.PropertyMap#serializeValues(InvocationContext)
    */
   public String serializeValues(InvocationContext context)
   {
      StringWriter writer = new StringWriter();

      if (serializeValues(writer, context))
      {
         return writer.toString();
      }
      else
      {
         return null;
      }
   }

   /**
    * @see nexj.core.util.PropertyMap#deserializeValues(java.lang.String, InvocationContext)
    */
   public void deserializeValues(Object serializedValues, InvocationContext context)
   {
      TransferObject tobj;

      if (serializedValues == null)
      {
         tobj = new TransferObject(0);
      }
      else
      {
         try
         {
            Reader reader;

            if (serializedValues instanceof String)
            {
               reader = new StringReader((String)serializedValues);
            }
            else
            {
               reader = new InputStreamReader(((Binary)serializedValues).getInputStream(), "UTF-8");
            }

            tobj = (TransferObject)new TextUnmarshaller(context).deserialize(reader);
         }
         catch (IOException e)
         {
            throw new UncheckedException("err.rpc.valueDeserialization", e);
         }
      }

      TransferObject instances = (TransferObject)tobj.findValue(":instances");
      InstanceFactory factory = null;

      for (int i = 0, n = m_flow.getVariableCount(); i != n; ++i)
      {
         Variable var = m_flow.getVariable(i);
         Object value = tobj.findValue(var.getName());

         if (value == null && instances != null)
         {
            value = instances.findValue(var.getName());

            if (value instanceof List || value instanceof TransferObject)
            {
               if (factory == null)
               {
                  factory = new InstanceFactory(context);
               }

               value = factory.instantiate(value);
            }
         }

         setValue(var, value);
      }

      for (int i = 0; i != m_nStepCount; ++i)
      {
         Activity activity = m_stepArray[i].getActivity();
         Object value = tobj.findValue(activity.getTokenName());

         if (value != null)
         {
            setToken(activity, value);
         }
      }
   }

   /**
    * @return True if the state is final.
    */
   public boolean isFinal()
   {
      return m_nStepCount == 0;
   }

   /**
    * Adds a step to clean up.
    * @param step The step to add.
    */
   protected void addCleanupStep(Step step)
   {
      if (step.getCleanupAssocCount() != 0)
      {
         if (m_cleanupStepList == null)
         {
            m_cleanupStepList = new ArrayList(4);
         }

         m_cleanupStepList.add(step);
      }
   }

   /**
    * Clears the cleanup step list.
    */
   protected void clearCleanupSteps()
   {
      if (m_cleanupStepList != null)
      {
         m_cleanupStepList.clear();
      }
   }

   /**
    * @return A collection of steps to cleanup.
    */
   public Collection getCleanupStepCollection()
   {
      if (m_cleanupStepList == null)
      {
         return Collections.EMPTY_LIST;
      }

      return m_cleanupStepList;
   }

   /**
    * @return The iterator over the steps that need cleanup.
    */
   public Iterator getCleanupStepIterator()
   {
      if (m_cleanupStepList == null)
      {
         return EmptyIterator.getInstance();
      }

      return m_cleanupStepList.iterator();
   }

   /**
    * Adds a step to the state.
    * @param step The element to add.
    */
   public void add(Step step)
   {
      if (step == null)
      {
         return;
      }

      if (m_nStepCount == m_stepArray.length)
      {
         Step[] stepArray = new Step[m_nStepCount << 1];

         System.arraycopy(m_stepArray, 0, stepArray, 0, m_nStepCount);
         m_stepArray = stepArray;
      }

      m_stepArray[m_nStepCount++] = step;
      m_bDirty = true;
   }

   /**
    * Removes a step from the state.
    * @param step The step to remove.
    * @param bCleanup True to clean up the associated resources.
    * @return True if the step has been removed successfully.
    */
   public boolean remove(Step step, boolean bCleanup)
   {
      for (int i = m_nStepCount - 1; i >= 0; --i)
      {
         if (m_stepArray[i] == step)
         {
            if (bCleanup)
            {
               addCleanupStep(step);
            }

            System.arraycopy(m_stepArray, i + 1, m_stepArray, i, m_nStepCount - i - 1);
            --m_nStepCount;
            m_bDirty = true;

            return true;
         }
      }

      return false;
   }

   /**
    * Removes a step from the state.
    * @param step The step to remove.
    * @return True if the step has been removed successfully.
    */
   public boolean remove(Step step)
   {
      return remove(step, true);
   }

   /**
    * Remove all of the steps from the state.
    */
   public void clear()
   {
      for (int i = 0; i < m_nStepCount; i++)
      {
         addCleanupStep(m_stepArray[i]);
         m_stepArray[i] = null;
      }

      m_nStepCount = 0;
      m_bDirty = true;
   }

   /**
    * Removes all the concurrent steps contained in a fork (directly or indirectly).
    * @param fork The fork to remove.
    * @return True if any steps have been removed.
    */
   public boolean removeConcurrent(Fork fork)
   {
      if (fork == null)
      {
         if (m_nStepCount != 0)
         {
            for (int i = 0; i < m_nStepCount; ++i)
            {
               addCleanupStep(m_stepArray[i]);
            }

            m_nStepCount = 0;
            m_bDirty = true;

            return true;
         }

         return false;
      }

      int k = 0;
      int nCount = fork.getConcurrentCount();

   outer:
      for (int i = 0; i < m_nStepCount; ++i)
      {
         Step step = m_stepArray[i];

         for (int j = 0; j < nCount; ++j)
         {
            if (fork.getConcurrent(j).contains(step.getActivity()))
            {
               addCleanupStep(step);

               continue outer;
            }
         }

         m_stepArray[k++] = step;
      }

      if (k != m_nStepCount)
      {
         m_nStepCount = k;
         m_bDirty = true;

         return true;
      }

      return false;
   }

   /**
    * Removes all the steps contained in an activity (directly or indirectly).
    * @return True if any steps have been removed.
    */
   public boolean remove(Activity activity)
   {
      int k = 0;

      for (int i = 0; i < m_nStepCount; ++i)
      {
         Step step = m_stepArray[i];

         if (activity.contains(step.getActivity()))
         {
            addCleanupStep(step);
         }
         else
         {
            m_stepArray[k++] = step;
         }
      }

      if (k != m_nStepCount)
      {
         m_nStepCount = k;
         m_bDirty = true;

         return true;
      }

      return false;
   }

   /**
    * Checks if the state contains a given step.
    * @param step The step to search for.
    * @return True if the state contains a given step.
    */
   public boolean contains(Step step)
   {
      for (int i = m_nStepCount - 1; i >= 0; --i)
      {
         if (m_stepArray[i] == step)
         {
            return true;
         }
      }

      return false;
   }

   /**
    * Checks if the state contains a named step.
    * @param sName The step name.
    */
   public boolean contains(String sName)
   {
      return contains(m_flow.getFlowStep(sName));
   }

   /**
    * Determines if any steps from a specified fork are active.
    * @param fork The fork to look for.
    * @return True if any elements from the specified fork are active.
    */
   public boolean containsConcurrent(Fork fork)
   {
      for (int i = 0; i < m_nStepCount; ++i)
      {
         if (m_stepArray[i].getFork() == fork)
         {
            return true;
         }
      }

      return false;
   }

   /**
    * Gets a flow element by index.
    * @param nIndex The element index.
    * @return The flow element.
    */
   public Step get(int nIndex)
   {
      assert nIndex >= 0 && nIndex < m_nStepCount;

      return m_stepArray[nIndex];
   }

   /**
    * @return The element count.
    */
   public int size()
   {
      return m_nStepCount;
   }

   /**
    * @return A list of pairs containing the active step names.
    */
   public Pair getStepNames()
   {
      Pair pair = null;

      for (int i = m_nStepCount - 1; i >= 0; --i)
      {
         pair = new Pair(m_stepArray[i].getName(), pair);
      }

      return pair;
   }

   /**
    * @return The first encountered transient step, or null if none.
    */
   public Step getTransientStep()
   {
      for (int i = 0; i < m_nStepCount; ++i)
      {
         Step step = m_stepArray[i];

         if (!step.isPersistent())
         {
            return step;
         }
      }

      return null;
   }

   /**
    * Sets the last run step.
    * @param step The last run step. Can be null.
    */
   public void setLastStep(Step step)
   {
      m_lastStep = step;
   }

   /**
    * @return The last run step, or null if none.
    */
   public Step getLastStep()
   {
      return m_lastStep;
   }

   /**
    * Proceeds to the next step. The caller should continue
    * invoking this method until it returns null.
    * @return A function to execute, or null if none.
    */
   public PCodeFunction run()
   {
      clearCleanupSteps();

      for (;;)
      {
         Step step = getTransientStep();

         dump();

         markActivities();

         if (step == null)
         {
            return null;
         }

         PCodeFunction fun = step.step(this);
         computeCleanupActivityCollection();

         if (fun != null)
         {
            m_lastStep = step;

            return bind(fun);
         }
         else
         {
            if (!m_cleanupActivityList.isEmpty())
            {
               return m_flow.getEmptyFunction();
            }
         }
      }
   }

   /**
    * Binds a properly compiled p-code function to the variable frame.
    * @param fun The function to bind.
    */
   public PCodeFunction bind(PCodeFunction fun)
   {
      return new PCodeFunction(fun.code, fun.constants, m_variableArray);
   }

   /**
    * Get the ThreadInfo object for the Fork with the given name.
    * @param sForkName The name of a Fork step in this activity.
    * @return The ThreadInfo object, or null if not found.
    */
   public ThreadInfo getThreadInfo(String sForkName)
   {
      return (ThreadInfo)m_threadInfoLookup.get(sForkName);
   }

   /**
    * Set the ThreadInfo object for the Fork with the given name.
    * @param sForkName The name of a Fork step in this activity.
    * @param info The ThreadInfo object.
    */
   public void setThreadInfo(String sForkName, ThreadInfo info)
   {
      m_threadInfoLookup.put(sForkName, info);
   }

   /**
    * Sets the state from string.
    * @param sState The string to parse.
    */
   public void fromString(String sState)
   {
      m_nStepCount = 0;

      if (sState != null)
      {
         StringTokenizer tokenizer = new StringTokenizer(sState);

         while (tokenizer.hasMoreTokens())
         {
            add(m_flow.getFlowStep(Integer.parseInt(tokenizer.nextToken())));
         }
      }
   }

   /**
    * @see java.lang.Object#toString()
    */
   public String toString()
   {
      StringBuffer buf = new StringBuffer(m_nStepCount << 2);

      Arrays.sort(m_stepArray, 0, m_nStepCount, ELEMENT_COMPARATOR);

      for (int i = 0; i < m_nStepCount; ++i)
      {
         if (i > 0)
         {
            buf.append(' ');
         }

         buf.append(m_stepArray[i].getOrdinal());
      }

      return buf.toString();
   }

   /**
    * Dumps the state to the logger.
    */
   public void dump()
   {
      if (s_logger.isDebugEnabled())
      {
         StringBuffer buf = new StringBuffer();

         buf.append(m_flow.toString());
         buf.append(" state: ");

         if (isFinal())
         {
            buf.append("final");
         }
         else
         {
            for (int i = 0; i < m_nStepCount; ++i)
            {
               if (i > 0)
               {
                  buf.append(", ");
               }

               Step step = m_stepArray[i];

               buf.append('[');

               if (step.isPersistent())
               {
                  buf.append(step.getOrdinal());
               }
               else
               {
                  buf.append("transient");
               }

               buf.append("]<");
               buf.append(step.toString());
               buf.append('>');
            }
         }

         s_logger.debug(buf);

         if (s_logger.isDumpEnabled() && m_flow.getVariableCount() != 0)
         {
            s_logger.dump("Variables:");

            for (int i = 0, n = m_flow.getVariableCount(); i != n; ++i)
            {
               Variable var = m_flow.getVariable(i);

               s_logger.dump(var.getName() + " = " + getValue(var));
            }
         }
      }
   }

   // inner classes

   /**
    * Keeps track of info for a specific branch of a Fork.
    */
   public static class ThreadInfo
   {
      // attributes

      /**
       * A zero-based index of which sub-Activity to execute in this thread.
       */
      protected int m_nIndex;

      // associations

      /**
       * The thread argument.
       */
      protected Object m_argument;

      // constructors

      /**
       * Construct a ThreadInfo object.
       * @param nIndex A zero-based index of which sub-Activity to execute in this thread.
       * @param arg The thread argument.
       */
      public ThreadInfo(int nIndex, Object arg)
      {
         m_nIndex = nIndex;
         m_argument = arg;
      }

      // operations

      /**
       * Get the zero-based index of which sub-Activity to execute in this thread.
       * @return The zero-based index of which sub-Activity to execute in this thread.
       */
      public int getIndex()
      {
         return m_nIndex;
      }

      /**
       * Get the thread argument.
       * @return The thread argument.
       */
      public Object getArgument()
      {
         return m_argument;
      }
   };
}
